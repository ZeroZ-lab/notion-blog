---
title: "Part.5: 情境感知：AI Agent 的知识之源 (Contextual Understanding: The Knowledge Source of AI Agents) "
description: ""
date: "2025-01-14"
category: "未分类"
tags: []
published: true
cover: "/images/posts/Part5-情境感知AI-Agent-的知识之源-Contextual-Understanding-/cover.jpg"
listed: false
---


## **引言:**


如果将 AI Agent 比作一个渴望知识的学徒，那么大语言模型 (LLM) 提供了强大的学习和推理能力，但它们自身携带的知识总是有限的，就像一个虽然聪明但缺乏特定领域经验的学徒。为了让 Agent 能够在特定领域或企业环境中发挥更大的作用，我们需要为其提供获取和利用外部知识的途径。**情境感知 (Contextual Understanding)** 能力，特别是 **RAG (Retrieval-Augmented Generation)** 技术，就如同为 Agent 打开了一扇通往知识宝库的大门，使其能够汲取所需的知识，并将其应用于生成更准确、更相关的响应。


```plain text
+-----------------+       +-----------------+       +-----------------+
|      LLM        |       |     RAG         |       |  Knowledge     |
| (强大的推理能力) |------>| (知识检索与增强) |------>|     Source      |
+-----------------+       +--------+--------+       | (企业内部文档,     |
                                   |               |  数据库, 网页等) |
                                   v               +-----------------+
                             +--------------+
                             |  AI Agent   |
                             | (情境感知能力) |
                             +--------------+

        (图 36. RAG 为 AI Agent 提供情境感知能力)
```


本章将深入探讨 RAG 技术如何为 AI Agent 赋能，使其成为企业级应用中更加强大的知识助手。


## **5.1 情境感知的重要性 (The Importance of Contextual Understanding)**


### **5.1.1 AI Agent 的知识局限性 (The Knowledge Limitations of AI Agents)**


尽管大型语言模型 (LLMs) 经过了海量数据的训练，拥有丰富的通用知识，但它们在企业级应用中仍然存在以下几方面的知识局限性：

- **5.1.1.1 预训练模型的知识边界:** LLMs 的知识来自于其预训练数据，而这些数据通常存在**时间**和**范围**的局限性。
    - **时间局限:** 预训练数据通常截止于某个时间点，LLM 无法获取最新的信息，例如最新的行业新闻、公司内部的政策文件、或某个特定产品的最新规格参数。例如，一个在 2023 年之前数据上训练的 LLM 可能不知道 2023 年之后发生的重要事件，也无法回答一些需要实时信息的问题。
    - **范围局限:** 预训练数据的范围通常是有限的，无法覆盖所有领域和所有类型的知识。例如，一个通用的 LLM 可能缺乏特定领域的专业知识，例如医疗、法律、金融等，也无法获取企业内部的私有知识，例如产品文档、技术手册、会议记录等。

        ```plain text
        +-----------------+       +-------------------+
        |  Pre-trained    |       |  Knowledge Gap    |
        |      LLM        |------>| (Specific Domain, |
        | (通用知识)       |       |  Real-time Info)  |
        +-----------------+       +-------------------+
        
             (图 37. LLM 的知识局限性)
        ```

- **5.1.1.2 企业内部知识的私有性:** 企业内部存在大量的私有知识，例如产品文档、技术手册、会议记录、项目文档、员工的专业知识等。这些信息通常不会公开，因此无法包含在 LLM 的预训练数据中，这就造成了 LLM 知识的缺失。例如，一个通用的 LLM 可能无法回答 “我们公司产品的最新版本有哪些新功能？” 或 “项目 A 的当前进度如何？” 等问题。

    ```plain text
    ```
    +------------+         +-----------------------+
    |  Public    |         |  Private Enterprise   |
    |  Knowledge |         |     Knowledge         |
    +------------+         +-----------+-----------+
           ^                             |
           |                             |
    +------+------+             +-------v--------+
    |    LLM     |             |    ???         |
    | (Pre-trained|             | (Inaccessible  |
    |  Data)     |             |  to LLM)       |
    +------------+             +----------------+
    
        (图 38. 企业私有知识的不可访问性)
    ```
    ```

- **5.1.1.3 实时信息的需求:** 许多企业级应用需要 Agent 能够实时获取和利用最新的信息，例如股票价格、新闻事件、天气预报等。而 LLM 的预训练数据通常是静态的，无法满足这种实时性的需求。例如，一个股票交易 Agent 需要实时获取股票的最新价格和市场行情，才能做出正确的交易决策。
- **5.1.1.4 专业领域知识:** 大多数 LLM 缺乏特定领域的专业知识，而在企业级应用中，往往需要 Agent 具备特定领域的专业知识，例如医疗、法律、金融等。例如，一个医疗诊断 Agent 需要具备医学专业知识，才能根据患者的症状和检查报告进行诊断。

### **5.1.2 情境感知 (Contextual Understanding): 弥合知识鸿沟**


为了弥补 LLM 的知识局限性，我们需要赋予 AI Agent **情境感知 (Contextual Understanding)** 的能力。


**5.1.2.1 什么是情境感知:** 情境感知是指 AI Agent 能够根据当前的上下文 (Context) 来理解用户的意图，并生成相关的响应。上下文可以包括：

- **当前的对话历史:** Agent 需要记住之前的对话内容，以便理解当前对话的语境。
- **用户的个人信息:** 例如用户的姓名、职位、偏好等，可以帮助 Agent 提供个性化的服务。
- **外部知识库:** 例如公司的产品文档、技术手册、FAQ 等，可以为 Agent 提供特定领域的知识。
- **实时信息:** 例如股票价格、新闻事件、天气预报等，可以帮助 Agent 做出更符合实际情况的决策。

```plain text
+-------------------+
|  Contextual       |
| Understanding     |
|                   |
| +--------------+  |
| |  Current     |  |
| |  Conversation|  |
| |  History     |  |
| +-------+------+  |
|         |         |
| +-------v------+  |
| | User Profile |  |
| |  (Preferences,|  |
| |   History)   |  |
| +-------+------+  |
|         |         |
| +-------v------+  |
| | External     |  |
| | Knowledge    |  |
| |  Base        |  |
| +-------+------+  |
|         |         |
| +-------v------+  |
| | Real-time    |  |
| |  Information |  |
| +--------------+  |
+-------------------+

      (图 39. 情境感知的组成部分)
```


**5.1.2.2 情境感知的重要性:**


情境感知能力对于构建企业级 AI Agent 至关重要, 它可以:

- **提高准确性:** 通过获取和利用相关的上下文信息, Agent 可以更准确地理解用户的需求, 并生成更准确的响应。
- **增强相关性:** Agent 可以根据上下文信息, 提供与当前情境更相关的回答或建议, 避免答非所问。
- **实现个性化:** Agent 可以根据用户的个人信息和历史记录, 提供个性化的服务和体验。
- **支持复杂任务:** 对于需要多轮交互和多个步骤才能完成的任务, Agent 可以利用上下文信息来跟踪任务的进度, 并进行必要的推理和规划。

**5.1.2.3 RAG (Retrieval-Augmented Generation) 的引入:**


**RAG (Retrieval-Augmented Generation)** 技术是实现情境感知的关键。RAG 的核心思想是将**检索 (Retrieval)** 和**生成 (Generation)** 相结合, **利用检索到的相关信息来增强 LLM 的生成能力。**


**简而言之, RAG 为 LLM 提供了访问外部知识库的途径, 弥补了其知识局限性, 使得 Agent 能够更好地理解上下文, 并生成更符合情境的响应。**


在接下来的内容中,  我们将深入探讨 RAG 的核心概念和技术实现。


## **5.2 RAG 的核心概念 (Core Concepts of RAG)**


RAG (Retrieval-Augmented Generation) 是一种结合了**信息检索 (Information Retrieval)** 和**文本生成 (Text Generation)** 的框架,  旨在提高大型语言模型 (LLM) 的知识丰富度和响应准确性。它通过从外部知识库中检索与输入查询相关的文档或段落,  并将这些检索到的信息作为上下文,  来增强 LLM 的生成能力。


可以将 RAG 比作一位学者在撰写论文时的过程:  首先根据论文主题 (Query) **检索 (Retrieve)** 相关的文献资料 (Knowledge Source),  然后基于检索到的资料以及自身的知识进行思考和创作,  最终**生成 (Generate)** 论文 (Response)。


```plain text
+-----------------+       +-----------------+       +-----------------+
|  Query/Prompt   |------>|     Retriever   |------>|    Generator    |
| (论文主题)       |       |  (检索相关文献)   |       |    (LLM +       |
+-----------------+       +--------+--------+       |     Context)    |
       |                        |             |   (基于检索到的信息 |
       |                        v             v    和自身知识写作)    |
       |                +--------------+   +-----------------+
       +-------------->|  Knowledge   |   |     Response    |
                       |   Source     |   |     (论文)      |
                       | (文献数据库)   |   +-----------------+
                       +--------------+

               (图 40. RAG 流程类比)
```


RAG 模型主要由三个核心组件构成：**检索器 (Retriever)**、**增强器 (Augmenter)** 和 **生成器 (Generator)**。


### **5.2.1 检索 (Retrieval):**

- **检索的目标:** 根据用户的查询 (Query), 从知识库 (Knowledge Base) 中检索相关的文档或段落。这里的 “相关” 指的是语义上的相关, 而不仅仅是关键词匹配。例如, 对于查询 “AI Agent 的应用”, 检索到的文档应该与 AI Agent 的应用场景相关, 即使文档中没有出现 “AI Agent 的应用” 这几个字。
- **检索的方法:**
    - **基于关键词的检索:** 使用传统的全文检索技术, 例如 TF-IDF、BM25 等, 根据关键词匹配来检索文档。这种方法的优点是简单、高效, 缺点是难以处理语义层面的相关性, 例如, 当查询和文档使用不同的词语表达相同的意思时, 基于关键词的检索可能无法找到相关的文档。
    - **基于语义的检索:** 使用向量化技术 (例如, Sentence Transformers, DPR 等), 将查询和文档都转换成向量表示, 然后通过计算向量之间的相似度来检索相关的文档。这种方法的优点是能够捕捉到查询和文档之间的语义相关性, 即使它们使用了不同的词语, 缺点是计算开销较大, 需要使用向量数据库来存储和检索向量。

        ```plain text
        +----------+         +-----------------+       +-----------------+
        |  Query   | ------> |  Vector Embeddings|------>|  Vector        |
        | (文本)   |         |   (Encoder)     |       |  Database      |
        +----------+         +--------+--------+       | (Similarity    |
             |                          |               |   Search)      |
             |                          |               +--------+--------+
             |                          v                        |
             |              +-------------------+               |
             +------------->|  Document         |               |
                            |  Embeddings      |               |
                            +-------------------+               |
                                     ^                        |
                                     |                        |
                            +-------------------+               |
                            |  Document         |               |
                            |   Preprocessing   | <-------------+
                            +-------------------+
        
                      (图 41. 基于语义的检索)
        ```

    - **混合检索:** 结合关键词检索和语义检索, 以提高检索的准确性和召回率。例如, 可以先使用关键词检索快速筛选出一批候选文档, 然后使用语义检索对候选文档进行重新排序, 或者将关键词检索和语义检索的结果进行加权融合。
- **检索的评价指标:** 常用的评价指标包括准确率 (Precision)、召回率 (Recall)、F1 值 (F1-score)、平均倒数排名 (Mean Reciprocal Rank, MRR)、归一化折损累计增益 (Normalized Discounted Cumulative Gain, NDCG) 等。
- **检索器 (Retriever):** 负责执行检索任务的组件, 可以是传统的全文检索引擎 (例如, Elasticsearch), 也可以是基于神经网络的检索模型 (例如, DPR), 或者两者的结合。

### **5.2.2 增强 (Augmentation):**

- **上下文的构建:** 将检索到的文档或段落作为上下文 (Context), 与用户的查询一起输入到 LLM 中。上下文可以提供 LLM 所不具备的知识, 例如, 特定领域的知识、最新的信息、私有的数据等, 从而增强 LLM 的生成能力。
- **Prompt 的设计:** 需要设计合适的 Prompt 模板, 将上下文信息有效地传递给 LLM, 并引导 LLM 利用上下文信息生成响应。例如：

    ```plain text
    Context: {context}
    
    Question: {question}
    
    Answer:
    ```


    或者,  可以使用更复杂的 Prompt 模板,  例如,  添加一些指令,  要求 LLM 必须基于上下文进行回答,  不能编造信息等。例如：


    ```plain text
    You are a helpful assistant. Answer the question based on the context below.
    
    Context: {context}
    
    Question: {question}
    
    Answer:
    ```

- **上下文的选择和整合:** 当检索到多个相关的文档或段落时, 需要选择和整合最相关的部分作为上下文。
    - **选择策略:** 可以根据相关性得分对检索到的文档或段落进行排序, 选择得分最高的几个; 或者, 可以使用一些文本摘要算法, 对检索到的文档或段落进行压缩和整合。
    - **长度控制:** 由于 LLM 的输入长度有限, 需要控制上下文的长度, 避免 Prompt 超过 LLM 的最大输入长度限制。例如, 可以设置一个最大上下文长度, 当检索到的上下文超过这个长度时, 可以根据相关性进行截断, 或者使用一些文本摘要算法来压缩上下文的长度。
    - **多文档整合:** 当检索到多个相关文档时, 需要将这些文档的内容整合到一个上下文中, 并处理文档之间的重复、冗余和冲突信息。

### **5.2.3 生成 (Generation):**

- **基于上下文的生成:** LLM 利用增强后的输入 (包括用户的查询和检索到的上下文) 来生成最终的响应。LLM 可以根据上下文信息, 生成更准确、更相关的答案, 并提供更多的细节和解释。
- **生成模型的选择:** 可以使用任何合适的 LLM 作为生成模型, 例如, GPT-3, LLaMA, Claude 等。不同的 LLM 在生成能力、推理能力、知识覆盖范围等方面存在差异, 需要根据具体的应用需求选择合适的 LLM。
- **生成结果的后处理:** 可以对 LLM 生成的响应进行一些后处理, 例如, 格式化、润色、过滤等, 以提高响应的质量和可用性。例如, 可以对生成的文本进行语法检查和修正, 或者删除一些不相关或重复的内容, 或者将生成的代码格式化成特定的风格。

**总结:**


RAG 通过将检索和生成相结合,  为 LLM 提供了外部知识库的支持,  从而增强了 LLM 的生成能力,  使其能够生成更准确、更相关的响应。RAG 已经成为构建企业级 AI Agent 的关键技术之一,  并在许多应用场景中取得了显著的效果。


## **5.3 上下文管理系统的实现 (Implementing Context Management)**


为了实现 RAG, 我们需要构建一个上下文管理系统, 负责处理文档、存储上下文、执行检索等操作。在本教程中, 我们将使用 **ChromaDB 向量数据库** 来存储和检索上下文, 并使用 **LangChain** 框架来处理文档和构建 RAG 流程。


### **5.3.1 技术选型：向量数据库 (Technology Selection: Vector Databases)**

- **向量数据库的作用:** 向量数据库专门用于存储和检索向量数据, 它可以根据向量之间的相似度来查找最相关的文档或段落。这对于实现 RAG 中的检索组件至关重要。
- **向量数据库的特点:**
    - **高效的相似性搜索:** 向量数据库使用特殊的索引结构和算法, 可以高效地执行相似性搜索, 例如, 近似最近邻搜索 (Approximate Nearest Neighbor, ANN)。这使得 Agent 能够快速找到与用户查询最相关的上下文, 即使是在大规模的文档集合中。
    - **对高维向量的支持:** 向量数据库可以支持高维向量的存储和检索, 例如, LLM 生成的嵌入向量通常具有数百甚至数千个维度。这使得 Agent 能够处理复杂的语义信息, 并进行更准确的检索。
    - **可扩展性:** 一些向量数据库支持分布式部署, 可以水平扩展, 以处理海量的向量数据。这使得 Agent 能够应对大规模的企业级应用场景。
- **常用的向量数据库:** 常用的向量数据库包括 ChromaDB, FAISS, Milvus, Pinecone, Weaviate 等, 它们各有优缺点, 需要根据具体的应用场景进行选择。
- **选择 ChromaDB 的理由:** 在本教程中, 我们选择 ChromaDB 作为示例, 主要是因为:
    - **轻量级:** ChromaDB 是一个轻量级的向量数据库, 易于安装和使用, 不需要复杂的配置。这使得开发者可以快速上手, 并在本地环境中轻松部署。
    - **嵌入式:** ChromaDB 可以作为嵌入式数据库运行, 也可以作为独立的数据库服务运行。这使得开发者可以根据自己的需求选择合适的部署方式。
    - **支持 in-memory 和持久化存储:** ChromaDB 可以将向量数据存储在内存中, 以提高检索速度, 也可以将数据持久化到磁盘上, 以保证数据的持久性。这使得 Agent 能够根据不同的场景选择合适的存储方式, 例如, 对于需要快速响应的任务, 可以将数据存储在内存中; 对于需要长期保存的数据, 可以将数据持久化到磁盘上。
    - **提供 Python API:** ChromaDB 提供了简单易用的 Python API, 可以方便地与 LangChain 等框架集成。这使得开发者可以使用 Python 代码来操作 ChromaDB 数据库, 例如, 创建集合、添加文档、执行查询等。

### **5.3.2** **`ContextManager`** **类:**


为了方便地管理上下文, 我们创建了一个 `ContextManager` 类, 它封装了与 ChromaDB 交互的具体实现, 提供了索引文档、检索上下文等功能。


```python
class ContextManager:
    def __init__(self, collection_name: str, persist_dir: str = "context_db", chunk_size: int = 1000, chunk_overlap: int = 200):
        self.persist_dir = persist_dir
        self.collection_name = collection_name
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap
        # Initialize ChromaDB
        self.client = chromadb.PersistentClient(path=persist_dir)
        self.collection = self.client.get_or_create_collection(
            name=collection_name,
            # embedding_function=SentenceTransformerEmbeddingFunction() # Use default
            metadata={"hnsw:space": "cosine"} # l2 (default), cosine, or ip
        )
        self._current_context = ""
        self._current_query = ""

    def initialize(collection_name: str, persist_dir: str = "context_db"):
        return ContextManager(collection_name, persist_dir)

    def _extract_text_from_pdf(self, pdf_path: str) -> str:
        """
        Extracts text content from a given PDF file path.
        """
        return extract_text_from_pdf(pdf_path)

    def _generate_document_id(self, chunk: str, metadata: Dict[str, Any]) -> str:
        """
        Generates a unique ID for a document chunk based on its content and metadata.
        """
        return generate_document_id(chunk, metadata)

    def index_document(self,
                   pdf_path: str,
                   metadata: Optional[Union[Dict[str, Any], DocumentMetadata]] = None) -> bool:
        """
        Index a PDF document into the vector store.
        """
        try:
            # Convert metadata to DocumentMetadata if it's a dict
            if isinstance(metadata, dict):
                metadata = DocumentMetadata.from_dict(metadata)
            elif metadata is None:
                metadata = DocumentMetadata(source=os.path.basename(pdf_path))

            # Extract text from PDF
            text = self._extract_text_from_pdf(pdf_path)

            # Split text into chunks using LangChain's text splitter
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=self.chunk_size,
                chunk_overlap=self.chunk_overlap
            )
            chunks = text_splitter.split_text(text)

            # Generate unique IDs and prepare metadata
            ids = [self._generate_document_id(chunk, metadata.to_dict()) for chunk in chunks]
            metadatas = [metadata.to_dict() for _ in chunks]

            # Add to ChromaDB
            self.collection.add(
                documents=chunks,
                ids=ids,
                metadatas=metadatas
            )

            return True
        except Exception as e:
            print(f"Error indexing document {pdf_path}: {str(e)}")
            return False

    def query(self,
            query: str,
            num_results: int = 3,
            filter_metadata: Optional[Dict[str, Any]] = None) -> str:
        """
        Query the context and return relevant information.
        """
        try:
            self._current_query = query

            # Prepare query parameters
            query_params = {
                "query_texts": [query],
                "n_results": num_results
            }
            if filter_metadata:
                query_params["where"] = filter_metadata

            # Execute query
            results = self.collection.query(**query_params)

            # Format the context with metadata
            context_parts = []
            for i, (doc, metadata) in enumerate(zip(
                results['documents'][0],
                results['metadatas'][0]
            ), 1):
                source = metadata.get('source', 'Unknown source')
                context_parts.append(
                    f"Relevant Context {i} (from {source}):\\n{doc}\\n"
                )

            self._current_context = "\\n".join(context_parts)
            return self._current_context

        except Exception as e:
            print(f"Error executing query: {str(e)}")
            self._current_context = ""
            return ""

    def clear_context(self):
        """
        Clears the current context and query.
        """
        self._current_context = ""
        self._current_query = ""
```


**代码解释:**

- **`__init__(self, collection_name: str, persist_dir: str = "context_db", chunk_size: int = 1000, chunk_overlap: int = 200)`****:**
    - `collection_name`: 指定 ChromaDB 集合的名称, 用于区分不同的上下文集合。
    - `persist_dir`: 指定 ChromaDB 数据存储的目录。
    - `chunk_size`: 指定文档分块的大小, 默认为 1000。
    - `chunk_overlap`: 指定相邻文档块之间的重叠大小, 默认为 200。
    - `self.client = chromadb.PersistentClient(path=persist_dir)`: 创建一个 ChromaDB 的持久化客户端, 数据将存储在 `persist_dir` 指定的目录中。
    - `self.collection = self.client.get_or_create_collection(name=collection_name, metadata={"hnsw:space": "cosine"})`: 获取或创建名为 `collection_name` 的集合, 并指定使用余弦距离 (`"hnsw:space": "cosine"`) 来计算向量之间的相似度。
    - `self._current_context = ""`: 初始化当前上下文为空字符串。
    - `self._current_query = ""`: 初始化当前查询为空字符串。
- **`initialize(collection_name: str, persist_dir: str = "context_db")`****:**
    - 这是一个类方法 (使用 `@classmethod` 装饰器), 用于创建一个新的 `ContextManager` 实例。
- **`_extract_text_from_pdf(self, pdf_path: str) -> str`****:**
    - 这是一个私有方法, 用于从 PDF 文件中提取文本。
    - **注意:** 这个方法是一个占位符, 需要根据具体的 PDF 解析库 (例如 PyPDF2, PyMuPDF 等) 进行实现。
- **`_generate_document_id(self, chunk: str, metadata: Dict[str, Any]) -> str`****:**
    - 这是一个私有方法, 用于为每个文档块生成唯一的 ID。
    - **注意:** 这个方法是一个占位符, 需要根据具体的 ID 生成策略进行实现。例如, 可以使用 UUID, 或者对文档块的内容和元数据进行哈希。
- **`index_document(self, pdf_path: str, metadata: Optional[Union[Dict[str, Any], DocumentMetadata]] = None) -> bool`****:**
    - **作用:** 将一个 PDF 文档索引到向量数据库中。
    - **参数:**
        - `pdf_path`: PDF 文档的路径。
        - `metadata`: 文档的元数据, 可以是一个字典, 也可以是一个 `DocumentMetadata` 对象。
    - **流程:**
        1. 处理元数据, 将其转换为 `DocumentMetadata` 对象。
        2. 调用 `_extract_text_from_pdf` 方法提取 PDF 文档中的文本。
        3. 使用 `RecursiveCharacterTextSplitter` 将文本分割成块 (chunks)。
        4. 为每个块生成唯一的 ID, 并准备元数据。
        5. 使用 `self.collection.add` 方法将文档块、ID 和元数据添加到 ChromaDB 集合中。
    - **返回值:** 如果索引成功, 返回 `True`; 否则, 返回 `False`。
- **`query(self, query: str, num_results: int = 3, filter_metadata: Optional[Dict[str, Any]] = None) -> str`****:**
    - **作用:** 根据查询从向量数据库中检索相关的文档块, 并返回格式化后的上下文信息。
    - **参数:**
        - `query`: 用户的查询文本。
        - `num_results`: 需要检索的文档块的数量, 默认为 3。
        - `filter_metadata`: 可选的元数据过滤条件, 用于根据元数据对检索结果进行过滤。
    - **流程:**
        1. 将查询文本存储在 `self._current_query` 中。
        2. 准备查询参数, 包括查询文本和返回结果的数量。
        3. 如果提供了 `filter_metadata` 参数, 则将其添加到查询参数中。
        4. 使用 `self.collection.query` 方法执行查询, 获取检索结果。
        5. 遍历检索结果, 提取文档块和元数据, 并将每个文档块格式化成以下形式:

            ```plain text
            Relevant Context [序号] (from [文档来源]):
            [文档块内容]
            ```


            例如:


            ```plain text
            Relevant Context 1 (from example.pdf):
            This is the first relevant document chunk.
            It contains information related to the query.
            
            Relevant Context 2 (from another_document.txt):
            This is the second relevant document chunk.
            It provides additional context for the query.
            ```

    1. 将格式化后的上下文信息存储在 `self._current_context` 中, 并返回该字符串。
    - **返回值:** 格式化后的上下文信息, 如果查询失败, 则返回空字符串。
- **`clear_context(self)`****:**
    - **作用:** 清除当前的上下文和查询。

```plain text
+-----------+       index_document()       +---------------+
    |  Document | -------------------------->| ContextManager|
    | (PDF, etc.)|                             +---------------+
    +-----------+                                   |
                                                    | Stores data in
                                                    v
                                            +-----------------+
                                            | Vector Database |
                                            |   (ChromaDB)    |
                                            +-----------------+
          ^                                         |
          |                                         | Queries with
          |                                         v
    +-----------+       query()           +-----------------+
    |   User    |------------------------>|   Context       |
    |  Query    |                             |   Manager       |
    +-----------+                             +-----------------+
          |                                         ^
          |  Returns context                      |
          v                                         |
    +-----------+                                 |
    |   Agent   |---------------------------------+
    +-----------+

    (图 34. ContextManager 工作流程示意图)
```


**`ContextManager`** **类提供了一个简洁的接口来管理上下文, Agent 可以通过这个接口来索引文档、检索上下文, 而无需关心底层的向量数据库操作。**


### **5.3.3** **`DocumentMetadata`** **类:**

- **作用:** `DocumentMetadata` 类用于存储和管理文档的元数据。元数据是关于数据的数据, 它可以提供有关文档的额外信息, 例如文档的来源、类型、作者、创建时间、标签等。
- **代码:**

    ```python
    class DocumentMetadata:
        def __init__(self, source: str = "", doc_type: str = "", author: str = "", created_at: Optional[datetime] = None, tags: Optional[str] = None):
            self.source = source
            self.doc_type = doc_type
            self.author = author
            self.created_at = created_at if created_at else datetime.now()
            self.tags = tags
    
        def to_dict(self):
            return {
                "source": self.source,
                "doc_type": self.doc_type,
                "author": self.author,
                "created_at": self.created_at.isoformat(),
                "tags": self.tags
            }
    
        @staticmethod
        def from_dict(data: Dict[str, Any]):
            created_at_str = data.get("created_at")
            created_at = datetime.fromisoformat(created_at_str) if created_at_str else None
            return DocumentMetadata(
                source=data.get("source"),
                doc_type=data.get("doc_type"),
                author=data.get("author"),
                created_at=created_at,
                tags=data.get("tags")
            )
    ```

- **属性:**
    - `source`: 文档的来源, 例如文件名、URL 等。
    - `doc_type`: 文档的类型, 例如 "pdf"、"txt"、"html" 等。
    - `author`: 文档的作者。
    - `created_at`: 文档的创建时间。
    - `tags`: 文档的标签, 用于分类和检索。
- **方法:**
    - `to_dict(self)`: 将 `DocumentMetadata` 对象转换为字典。
    - `from_dict(data: Dict[str, Any])`: 从字典中创建 `DocumentMetadata` 对象。

**元数据的作用:**

- **文档检索和过滤:** 可以根据元数据来检索和过滤文档, 例如, 检索特定作者、特定类型的文档, 或者创建时间在某个范围内的文档。
- **上下文理解:** 元数据可以提供关于文档的上下文信息, 帮助 Agent 更好地理解文档的内容和来源。例如, 知道文档的作者和创建时间, 可以帮助 Agent 评估文档的可信度和时效性。
- **结果排序:** 可以根据元数据对检索结果进行排序, 例如, 将最新的文档排在前面, 或者将来自权威来源的文档排在前面。
- **审计和跟踪:** 元数据可以用于跟踪文档的来源和处理历史, 支持审计和合规性要求。

### **5.3.4 核心方法详解:**


**5.3.4.1** **`index_document`****:**

- **方法作用:** `index_document` 方法负责将一个 PDF 文档 (或其他格式的文档, 取决于 `_extract_text_from_pdf` 方法的实现) 处理并索引到向量数据库中, 以便后续进行检索。
- **方法参数:**
    - `pdf_path`: 需要索引的 PDF 文档的路径。
    - `metadata`: 文档的元数据, 可以是一个字典, 也可以是一个 `DocumentMetadata` 对象。
- **方法流程:**
    1. **元数据处理:** 如果传入的 `metadata` 是字典, 则将其转换为 `DocumentMetadata` 对象; 如果 `metadata` 为 `None`, 则根据 `pdf_path` 创建一个默认的 `DocumentMetadata` 对象, 其中 `source` 属性设置为文件名。
    2. **文本提取:** 调用 `_extract_text_from_pdf` 方法从 PDF 文档中提取文本内容。这个方法需要根据具体的 PDF 解析库进行实现。
    3. **文本分块:** 使用 `RecursiveCharacterTextSplitter` 将提取到的文本分割成更小的块 (chunks)。这里使用了 LangChain 提供的文本分割器, 可以根据 `chunk_size` (块大小) 和 `chunk_overlap` (块之间的重叠大小) 对文本进行分割。
        - **为什么需要分块？**
        因为大模型有最大输入长度的限制, 并且太长的文本段落不利于进行精准的语义匹配。
        - **如何选择合适的** **`chunk_size`** **和** **`chunk_overlap`****？**`chunk_size` 和 `chunk_overlap` 的选择需要根据具体的应用场景和文档的特点进行权衡。一般来说, `chunk_size` 越大, 每个块中包含的信息越多, 但是检索的精度可能会降低; `chunk_size` 越小, 检索的精度可能会提高, 但是可能会丢失上下文信息。`chunk_overlap` 可以用来控制块之间的信息冗余, 避免因为分块导致的信息丢失。一个常用的策略是选择 `chunk_size` 为 512 或 1024, `chunk_overlap` 为 100 或 200。
    4. **ID 生成:** 调用 `_generate_document_id` 方法为每个文本块生成唯一的 ID。ID 的生成策略可以根据具体需求进行定制, 例如, 可以使用 UUID, 或者对文本块的内容和元数据进行哈希。
    5. **准备元数据:** 为每个文本块准备元数据, 这里使用了 `metadata.to_dict()` 将 `DocumentMetadata` 对象转换为字典, 并为每个块复制一份元数据。
    6. **添加到 ChromaDB:** 使用 `self.collection.add` 方法将文档块 (documents)、ID (ids) 和元数据 (metadatas) 添加到 ChromaDB 集合中。在添加文档到 ChromaDB 之前, 需要使用嵌入模型将文档块转换为向量表示, 然后才能将其存储到向量数据库中。在 `ContextManager` 类的初始化方法中, 已经指定了使用默认的嵌入函数, 因此这里不需要显式地调用嵌入函数。
    - **错误处理:** 使用 `try...except` 块来捕获可能出现的异常, 并在发生错误时记录日志并返回 `False`。
    - **返回值:** 如果索引成功, 返回 `True`; 否则, 返回 `False`。

    **代码示例:**


    ```python
    def index_document(self,
                       pdf_path: str,
                       metadata: Optional[Union[Dict[str, Any], DocumentMetadata]] = None) -> bool:
        """
        Index a PDF document into the vector store.
        """
        try:
            # Convert metadata to DocumentMetadata if it's a dict
            if isinstance(metadata, dict):
                metadata = DocumentMetadata.from_dict(metadata)
            elif metadata is None:
                metadata = DocumentMetadata(source=os.path.basename(pdf_path))
    
            # Extract text from PDF
            text = self._extract_text_from_pdf(pdf_path)
    
            # Split text into chunks using LangChain's text splitter
            text_splitter = RecursiveCharacterTextSplitter(
                chunk_size=self.chunk_size,
                chunk_overlap=self.chunk_overlap
            )
            chunks = text_splitter.split_text(text)
    
            # Generate unique IDs and prepare metadata
            ids = [self._generate_document_id(chunk, metadata.to_dict()) for chunk in chunks]
            metadatas = [metadata.to_dict() for _ in chunks]
    
            # Add to ChromaDB
            self.collection.add(
                documents=chunks,
                ids=ids,
                metadatas=metadatas
            )
    
            return True
        except Exception as e:
            print(f"Error indexing document {pdf_path}: {str(e)}")
            return False
    ```


    **5.3.4.2** **`query`****:**

    - **方法作用:** `query` 方法负责根据用户的查询从向量数据库中检索相关的文档块, 并返回格式化后的上下文信息。
    - **方法参数:**
        - `query`: 用户的查询文本。
        - `num_results`: 需要检索的文档块的数量, 默认为 3。
        - `filter_metadata`: 可选的元数据过滤条件, 用于根据元数据对检索结果进行过滤。
    - **方法流程:**
        1. **存储当前查询:** 将 `query` 存储在 `self._current_query` 中, 以便后续使用。
        2. **准备查询参数:** 根据 `query` 和 `num_results` 构建查询参数, 其中 `query_texts` 参数指定了查询文本, `n_results` 参数指定了返回结果的数量。如果提供了 `filter_metadata` 参数, 则将其添加到查询参数的 `where` 字段中, 以实现根据元数据进行过滤。
        3. **执行查询:** 使用 `self.collection.query` 方法执行查询, 获取检索结果。ChromaDB 会根据查询向量和文档向量之间的相似度, 返回最相关的 `num_results` 个文档块。
        4. **格式化上下文:** 遍历检索结果, 提取文档块和元数据, 并将每个文档块格式化成以下形式:

            ```plain text
            Relevant Context [序号] (from [文档来源]):
            [文档块内容]
            ```


            例如:


            ```plain text
            Relevant Context 1 (from example.pdf):
            This is the first relevant document chunk.
            It contains information related to the query.
            
            Relevant Context 2 (from another_document.txt):
            This is the second relevant document chunk.
            It provides additional context for the query.
            ```

        5. **存储当前上下文:** 将格式化后的上下文信息存储在 `self._current_context` 中, 并返回该字符串。
        6. **错误处理:** 使用 `try...except` 块来捕获可能出现的异常, 并在发生错误时记录日志, 将 `self._current_context` 设置为空字符串, 并返回空字符串。

    **代码示例:**


    ```python
    def query(self,
                query: str,
                num_results: int = 3,
                filter_metadata: Optional[Dict[str, Any]] = None) -> str:
            """
            Query the context and return relevant information.
            """
            try:
                self._current_query = query
    
                # Prepare query parameters
                query_params = {
                    "query_texts": [query],
                    "n_results": num_results
                }
                if filter_metadata:
                    query_params["where"] = filter_metadata
    
                # Execute query
                results = self.collection.query(**query_params)
    
                # Format the context with metadata
                context_parts = []
                for i, (doc, metadata) in enumerate(zip(
                    results['documents'][0],
                    results['metadatas'][0]
                ), 1):
                    source = metadata.get('source', 'Unknown source')
                    context_parts.append(
                        f"Relevant Context {i} (from {source}):\\n{doc}\\n"
                    )
    
                self._current_context = "\\n".join(context_parts)
                return self._current_context
    
            except Exception as e:
                print(f"Error executing query: {str(e)}")
                self._current_context = ""
                return ""
    ```


    **5.3.4.3** **`_generate_document_id`****:**

    - **方法作用:** `_generate_document_id` 是一个私有方法, 用于为每个文档块生成唯一的 ID。
    - **实现策略:** 可以根据具体的需求选择合适的 ID 生成策略, 例如:
        - **UUID:** 可以使用 Python 的 `uuid` 模块生成 UUID (Universally Unique Identifier), 例如:

            ```python
            import uuid
            
            def _generate_document_id(self, chunk: str, metadata: Dict[str, Any]) -> str:
                return str(uuid.uuid4())
            ```

        - **哈希:** 可以对文档块的内容和元数据进行哈希, 生成一个唯一的哈希值作为 ID, 例如:

            ```python
            import hashlib
            import json
            
            def _generate_document_id(self, chunk: str, metadata: Dict[str, Any]) -> str:
                combined = f"{chunk}-{json.dumps(metadata, sort_keys=True)}".encode('utf-8')
                return hashlib.sha256(combined).hexdigest()
            ```

        - **自增 ID:** 可以使用一个计数器, 为每个文档块生成一个自增的 ID。这种方法需要考虑并发访问的情况, 以免生成重复的 ID。
    - **选择哪种 ID 生成策略取决于具体的应用场景和需求。** 例如, 如果需要保证 ID 的全局唯一性, 可以使用 UUID; 如果需要根据文档块的内容和元数据生成 ID, 可以使用哈希; 如果需要保证 ID 的顺序性, 可以使用自增 ID。

    **5.3.4.4** **`_extract_text_from_pdf`****:**

    - **方法作用:** `_extract_text_from_pdf` 是一个私有方法, 用于从 PDF 文件中提取文本内容。
    - **实现方法:** 可以使用 Python 的第三方库来解析 PDF 文件, 例如:
        - **PyPDF2:** 一个纯 Python 的 PDF 处理库, 可以用于提取文本、元数据、页面等。
        - **PyMuPDF:** 一个功能强大的 PDF 处理库, 支持多种 PDF 操作, 包括文本提取、图像提取、页面旋转等。
        - **textract:** 一个通用的文本提取库, 可以处理多种文档格式, 包括 PDF、DOCX、XLSX 等。
    - **示例代码 (使用 PyMuPDF):**

        ```python
        import fitz  # PyMuPDF
        
        def _extract_text_from_pdf(self, pdf_path: str) -> str:
            """
            Extracts text content from a given PDF file path.
            """
            try:
                doc = fitz.open(pdf_path)
                text = ""
                for page in doc:
                    text += page.get_text()
                return text
            except Exception as e:
                print(f"Error extracting text from PDF {pdf_path}: {str(e)}")
                return ""
        ```


    **5.3.4.5** **`_text_splitter`****:**

    - **对象作用:** `_text_splitter` 是一个文本分割对象, 用于将文本分割成更小的块, 以便更好地进行向量化和检索。
    - **初始化:** 在 `ContextManager` 的 `__init__` 方法中, 使用 `RecursiveCharacterTextSplitter` 初始化了一个 `_text_splitter` 对象:

        ```python
        from langchain.text_splitter import RecursiveCharacterTextSplitter
        # ... (在 ContextManager 的 __init__ 方法中)
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=self.chunk_size,
            chunk_overlap=self.chunk_overlap
        )
        ```

    - **参数说明:**
        - `chunk_size`: 指定每个块的大小 (字符数或 tokens 数)。
        - `chunk_overlap`: 指定相邻块之间的重叠大小, 用于保持上下文的连贯性。
        - 可以根据实际需求调整 `chunk_size` 和 `chunk_overlap` 的值, 以平衡块的大小和上下文的完整性。
    - **使用方法:** 在 `index_document` 方法中, 使用 `text_splitter.split_text(text)` 将提取到的文本分割成块。

    **5.4 将 RAG 集成到 Agent 架构中 (Integrating RAG into the Agent Architecture)**


    为了将 RAG 功能集成到 Agent 中, 我们需要在 `Agent` 类中添加与 `ContextManager` 交互的代码。


    ### **5.4.1 增强** **`Agent`** **类:**

    - **添加** **`_context`** **属性:** 在 `Agent` 类的 `__init__` 方法中, 添加一个 `_context` 属性, 用于存储 `ContextManager` 实例。

    ```python
    class Agent:
        def __init__(self,
                     name: str,
                     context: Optional[ContextManager] = None,
                     persistence: Optional[AgentPersistence] = None,
                     tool_registry: Optional[ToolRegistry] = None):
            # ... 其他属性初始化 ...
            self._context = context
            # ... 其他代码 ...
    ```

    - **初始化** **`_context`****:** 在 `Agent` 类的 `__init__` 方法中, 初始化 `_context` 属性。如果构造函数中传入了 `context` 参数, 则使用传入的 `ContextManager` 对象; 否则, `_context` 属性保持为 `None`, 表示不使用 RAG。

    ### **5.4.2 增添** **`set_context_query`** **方法:**

    - **方法作用:** 在 `Agent` 类中添加一个 `set_context_query` 方法, 用于设置当前的上下文查询, 并调用 `ContextManager` 的 `query` 方法来检索相关的上下文信息。
    - **代码实现:**

    ```python
    class Agent:
        # ... 其他方法 ...
        def set_context_query(self, query: str):
            if self._context:
                self._context.query(query)
        # ...
    ```

    - **方法说明:** `set_context_query` 方法接受一个查询字符串作为参数, 如果 Agent 已经配置了 `ContextManager` (即 `self._context` 不为 `None`), 则调用 `self._context.query(query)` 方法来检索相关的上下文信息。检索结果将存储在 `self._context._current_context` 中。

    ### **5.4.3 修改** **`_build_messages`** **方法:**

    - **修改目的:** 在 `_build_messages` 方法中, 添加对上下文的处理逻辑, 将检索到的上下文信息添加到 Prompt 中, 作为 LLM 的输入。
    - **代码实现:**

    ```python
    class Agent:
        # ... 其他方法 ...
        def _build_messages(self) -> List[Dict[str, str]]:
            """Build the messages list for the API call including system, instruction, history, context, and tools."""
            messages = [{"role": "system", "content": self.persona}]
    
            if self.instruction:
                messages.append({"role": "user", "content": f"Global Instruction: {self.instruction}"})
    
            # Add conversation history
            messages.extend(self.history)
    
            # Add context if available and relevant
            if self._context and self._context._current_context:
                messages.append({"role": "user", "content": f"Context: {self._context._current_context}"})
    
            # Add tools information
            if self.tool_registry:
                messages.append({"role": "user", "content": self.tool_registry.get_tools_prompt()})
    
            # Add current task if exists
            if self.task:
                messages.append({"role": "user", "content": f"Current Task: {self.task}"})
    
            return messages
    
        # ... 其他方法 ...
    ```

    - **代码解释:**
        - `if self._context and self._context._current_context:`: 判断 `_context` 属性是否存在, 以及 `_context._current_context` 是否为空, 如果两者都为真, 则说明存在有效的上下文信息。
        - `messages.append({"role": "user", "content": f"Context: {self._context._current_context}"})`: 将上下文信息添加到消息列表中, 作为 `user` 角色的消息。这里使用了一个简单的格式化字符串, 将上下文信息添加到 "Context: " 后面。

    **修改后的** **`_build_messages`** **方法会将检索到的上下文信息添加到 Prompt 中, 从而使 LLM 能够利用这些信息来生成响应。**


    ### **5.4.4 修改** **`execute`** **方法:**


    在 `Agent` 类的 `execute` 方法中,  我们需要在调用 LLM 生成响应之前,  设置上下文查询。


    ```python
    def execute(self, task: Optional[str] = None) -> str:
        """
        Execute the agent with the given task or use existing task if none provided.
        Updates conversation history with the interaction.
        """
        client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    
        if task is not None:
            self._task = task
    
        # 设置上下文查询,  触发 RAG 检索
        if self._context:
            self.set_context_query(self._task)
    
        # Use strategy if set
        if self._strategy:
            self._task = self._strategy.build_prompt(self._task, self._instruction)
    
        messages = self._build_messages()
    
        try:
            response = client.chat.completions.create(
                model="gpt-4-turbo", # or model of your choice
                messages=messages
            )
    
            response_content = response.choices[0].message.content
    
            # Parse for tool usage
            tool_usage = self._parse_tool_usage(response_content)
    
            if tool_usage:
                tool_name = tool_usage["name"]
                tool_params = tool_usage["parameters"]
    
                tool_result = self.execute_tool(tool_name, **tool_params)
    
                if tool_result.success:
                    response_content += f"\\nTool Result:\\n{tool_result.data}"
                else:
                    response_content += f"\\nTool Error:\\n{tool_result.error}"
            else:
                # Process response through strategy if set
                if self._strategy:
                    response_content = self._strategy.process_response(response_content)
    
            # Update history with the interaction
            if self.task:
                self._history.append({"role": "user", "content": self.task})
            self._history.append({"role": "assistant", "content": response_content})
    
            # Clear current task after execution
            self._task = ""
    
            return response_content
        except Exception as e:
            return f"An error occurred: {str(e)}"
    ```


    **代码解释:**

    - `if self._context:`: 检查是否设置了 `ContextManager`。
    - `self.set_context_query(self._task)`: 如果设置了 `ContextManager`, 则调用 `set_context_query` 方法, 将当前的 `self._task` (即用户的查询) 作为参数传入, 从而触发 `ContextManager` 执行检索操作, 并将检索结果存储在 `self._context._current_context` 中。

    **通过以上修改,  Agent 在执行任务时,  会自动使用** **`ContextManager`** **检索相关的上下文信息,  并将这些信息添加到 Prompt 中,  从而实现了 RAG 的功能。**


    ## **5.5 实际应用示例 (Practical Implementation)**


    现在,  让我们通过一个完整的示例来演示如何将 RAG 集成到 Agent 中,  并使用 RAG 来增强 Agent 的问答能力。


    ### **5.5.1 场景描述:**


    我们将创建一个**学术研究助理 Agent**,  它可以帮助用户查找和总结学术论文。该 Agent 将使用 **RAG 技术**,  从一个预先构建的论文数据库中检索相关的论文,  并根据检索到的论文来回答用户的问题。


    ### **5.5.2 示例步骤:**

    1. **初始化** **`ContextManager`** **并索引文档:**
        - 创建一个 `ContextManager` 实例, 用于管理上下文信息。
        - 准备一些示例文档 (例如, 几篇关于 AI Agent 的学术论文的 PDF 文件, 或者一些文本文件), 并使用 `index_document` 方法将这些文档索引到 ChromaDB 向量数据库中。
    2. **创建并配置 Agent:**
        - 创建一个 `Agent` 实例, 并传入 `ContextManager` 实例。
        - 设置 Agent 的角色 (Persona) 和指令 (Instructions)。例如, 可以将 Agent 的角色设置为一个学术研究助理, 指令可以设置为 “根据提供的上下文, 准确、简洁地回答用户的问题”。
    3. **查询和获取响应:**
        - 设置一个具体的问题 (Task), 例如, "请总结一下 AI Agent 的主要应用领域"。
        - 调用 `set_context_query` 方法, 将问题作为上下文查询, 触发 `ContextManager` 从向量数据库中检索相关的论文。
        - 调用 `execute` 方法, 执行 Agent 的逻辑, 生成最终的答案。
        - 打印 Agent 的响应。

    ### **5.5.3 示例代码:**


    ```python
    # 1. Initialize context and index the PDF
    print("\\nStep 1: Initializing context and indexing document...")
    context = ContextManager(
        collection_name="research_papers", # 使用一个新的 collection
        persist_dir="context_db"
    )
    
    pdf_path = "example_paper.pdf" # 这里需要替换成你自己的 PDF 文件路径，或者使用其他文本文件
    # 也可以多加几个 pdf_path, 或者使用文件夹
    metadata = DocumentMetadata(
        source=os.path.basename(pdf_path),
        doc_type="pdf",
        author="Demo Author",
        created_at=datetime.now(),
        tags="AI,Agent,Research"
    )
    
    # 确保文件存在
    if os.path.exists(pdf_path):
        success = context.index_document(pdf_path, metadata)
        if success:
            print(f"Successfully indexed document: {pdf_path}")
        else:
            print(f"Failed to index document: {pdf_path}")
    else:
        print(f"File not found: {pdf_path}")
        # 如果文件不存在，你可以选择跳过索引步骤，或者使用其他示例文档
    
    # 2. Create and configure the agent with context
    print("\\nStep 2: Creating agent with context...")
    agent = Agent("research_assistant", context=context)
    
    # Set agent persona and instruction
    agent.persona = """I am a helpful research assistant.
    I can use the provided context to answer questions accurately and in detail."""
    
    agent.instruction = """When answering questions:
    1. Focus on key principles and fundamentals
    2. Use clear and precise language
    3. Provide relevant examples where applicable
    4. Always refer to the provided context when answering questions.
    5. If the context does not contain the answer, state that you cannot find an answer in the provided context."""
    
    # 3. Query and get response using context
    print("\\nStep 3: Setting context and executing task...")
    context_query = "What are the main application areas of AI Agents?"
    agent.set_context_query(context_query)
    
    agent.task = f"""Based on the provided context, answer the following question:
    {context_query}"""
    
    response = agent.execute()
    print(f"Agent Response:\\n{response}")
    ```


    **代码说明:**

    1. **初始化** **`ContextManager`****:** 创建一个 `ContextManager` 实例, 并指定集合名称和持久化目录。
    2. **索引示例文档:** 这里我们假设有一个 PDF 文档 `"example_paper.pdf"`, 你需要将其替换为你自己的 PDF 文件路径。使用 `index_document` 方法将 PDF 文档索引到 ChromaDB 向量数据库中。
    3. **创建和配置 Agent:** 创建一个名为 `research_assistant` 的 Agent, 并传入 `ContextManager` 实例。
    4. **设置角色和指令:** 为 Agent 设置角色 (Persona) 和指令 (Instructions), 指导 Agent 的行为。
    5. **查询和获取响应:** 设置一个具体的问题, 并调用 `set_context_query` 方法来设置上下文查询, 然后调用 `execute` 方法来执行任务, 并打印 Agent 的响应。

    ### **5.5.4 预期输出:**


    Agent 的响应将基于 `example_paper.pdf` 文档的内容 (如果存在),  并结合 LLM 自身的知识来回答问题。如果 `example_paper.pdf` 包含了关于 AI Agent 应用领域的信息,  那么 Agent 的响应中将会包含这些信息。


    例如,  输出可能类似于:


    ```plain text
    Based on the provided context, AI Agents have several main application areas. These include:
    
    1. **Customer Support:** AI Agents can automate responses to frequently asked questions, handle multiple customer queries simultaneously, and provide support 24/7. The context mentions that customer support is a promising area for applying AI Agents. (from example_paper.pdf)
    2. **Coding Agents:** AI Agents can assist in code generation, debugging, and code review, significantly speeding up the development process. The context indicates that coding is one of the areas where AI Agents are being actively developed. (from example_paper.pdf)
    3. **Personalized Education:** AI Agents can act as personal tutors, adapting to the learning pace and style of individual students. The context suggests that personalized education is another potential application area. (from example_paper.pdf)
    4. **Healthcare:** AI Agents can assist in diagnosis, treatment planning, and patient monitoring. The context mentions that healthcare is a field where AI Agents can have a significant impact. (from example_paper.pdf)
    
    It is important to note that these are just a few examples, and the specific applications of AI Agents may vary depending on the context and the specific capabilities of the agents.
    ```


    ### **5.5.5 示例扩展:**

    - **尝试不同的问题:** 你可以尝试不同的问题, 看看 Agent 如何利用 RAG 技术来回答这些问题。
    - **添加更多文档:** 你可以向向量数据库中添加更多的文档, 以扩展 Agent 的知识库。
    - **调整 Prompt:** 你可以尝试修改 Agent 的角色 (Persona) 和指令 (Instructions), 看看这对 Agent 的行为有什么影响。
    - **结合其他推理策略:** 你可以尝试将 RAG 与 ReAct、Chain of Thought 或 Reflection 等推理策略结合起来, 以增强 Agent 的推理能力。
    - **使用不同的 LLM:** 你可以尝试使用不同的 LLM, 例如 Claude 3, 看看不同的 LLM 在 RAG 任务上的表现如何。
    - **评估 RAG 的效果:** 你可以使用一些标准的 QA 数据集来评估 RAG 的效果, 例如 SQuAD、Natural Questions 等, 并计算准确率、召回率等指标。

    ## **5.6 RAG 增强型代理的企业级优势 (Enterprise Benefits of RAG-Enhanced Agents)**


    将 RAG 技术集成到 AI Agent 中,  可以为企业带来多方面的优势,  使 Agent 成为更强大的企业级解决方案。


    ### **5.6.1 知识基础 (Knowledge Grounding):**

    - **确保准确性和相关性:** RAG 增强型 Agent 可以根据组织内部的特定知识库 (例如, 产品文档、技术手册、FAQ、内部 Wiki 等) 来生成响应, 从而确保响应的准确性和相关性。这对于企业环境至关重要, 因为在企业环境中, Agent 的响应必须符合内部政策、流程和特定领域的知识。
    - **支持多种数据源:** RAG 可以利用各种类型的数据源, 包括结构化数据 (例如, 数据库、电子表格)、非结构化数据 (例如, 文本文件、PDF、网页) 和半结构化数据 (例如, JSON、XML)。这使得 Agent 能够利用企业内部的各种数据资产, 提供更全面的信息。
    - **维护文档元数据和版本控制:** RAG 系统可以维护文档的元数据 (例如, 作者、创建时间、版本号等), 并支持版本控制, 从而实现信息的可追溯性和可审计性。这对于需要满足合规性要求的企业尤其重要。
    - **利用企业内部知识:** RAG 使企业能够充分利用其内部积累的知识和经验, 将其转化为 AI Agent 的能力, 从而提高企业的运营效率和决策质量。

    ### **5.6.2 动态信息更新 (Dynamic Information Updates):**

    - **实时更新知识库:** RAG 系统可以支持知识库的动态更新, 例如, 添加新的文档、删除过时的文档、修改现有的文档等。这使得 Agent 能够始终访问最新的信息, 并提供最新的答案。
    - **即时访问最新信息:** Agent 可以在检索阶段访问最新的信息, 而无需重新训练 LLM, 这对于信息快速变化的领域 (例如, 新闻、金融、科技等) 尤其重要。
    - **提高 Agent 的时效性:** 通过动态更新知识库, 可以确保 Agent 的响应始终是最新的, 从而提高 Agent 的时效性和实用性。
    - **支持增量学习:** Agent 可以通过不断学习新的文档, 来扩展自身的知识范围, 并提高自身的性能。

    ### **5.6.3 合规性和审计支持 (Compliance and Audit Support):**

    - **可追溯的信息来源:** RAG 可以维护响应和源文档之间的清晰链接, 从而支持可追溯性要求, 并方便进行审计。这对于受监管行业 (例如, 金融、医疗等) 非常重要, 因为这些行业需要对决策过程进行严格的审查和记录。
    - **元数据跟踪:** RAG 系统可以跟踪文档的来源、版本和使用情况, 提供清晰的审计跟踪。例如, 可以记录哪个 Agent 在什么时间使用了哪个版本的文档来生成响应。
    - **支持合规性要求:** RAG 可以帮助企业满足各种合规性要求, 例如, GDPR (通用数据保护条例)、HIPAA (健康保险流通与责任法案) 等, 通过确保 Agent 的响应基于可信赖的、受控的知识源, 并提供完整的审计跟踪。

    ### **5.6.4 提高决策质量 (Improved Decision Making):**

    - **更全面的信息:** RAG 可以为 Agent 提供更全面、更准确的信息, 从而支持 Agent 做出更好的决策。例如, 一个投资决策 Agent 可以利用 RAG 来检索相关的市场分析报告、公司财报、新闻事件等信息, 从而做出更明智的投资决策。
    - **减少偏差和错误:** 通过使用 RAG, 可以减少 Agent 对 LLM 预训练数据中可能存在的偏差和错误的依赖, 从而提高决策的质量。
    - **支持复杂推理:** RAG 可以为 Agent 提供更丰富的上下文信息, 从而支持更复杂的推理和分析。例如, 一个医疗诊断 Agent 可以利用 RAG 来检索相关的医学文献、病例报告等信息, 从而做出更准确的诊断。

    ### **5.6.5 增强客户体验 (Enhanced Customer Experience):**

    - **更准确的响应:** RAG 可以帮助 Agent 提供更准确、更相关的响应, 从而提高客户满意度。例如, 一个客服 Agent 可以利用 RAG 来检索客户的历史订单信息、常见问题解答等, 从而更快地解决客户的问题, 并提供更个性化的服务。
    - **更快的响应速度:** 通过预先构建索引和使用高效的检索算法, RAG 可以加快 Agent 的响应速度, 从而提升客户体验。
    - **个性化服务:** RAG 可以根据用户的个人信息和历史记录, 提供个性化的服务和推荐, 从而增强用户体验。例如, 一个电商 Agent 可以利用 RAG 来检索用户的购买历史和浏览记录, 从而推荐更符合用户需求的商品。

    ### **5.6.6 提高员工效率 (Increased Employee Productivity):**

    - **自动化信息检索:** RAG 可以帮助员工快速找到所需的信息, 从而减少搜索时间, 提高工作效率。例如, 一个销售人员可以利用 RAG Agent 来检索客户信息、产品信息、销售话术等, 从而更快地准备销售方案和回答客户的问题。
    - **知识共享和重用:** RAG 可以促进企业内部的知识共享和重用, 例如, 可以将各个部门的文档、报告、FAQ 等集中到一个知识库中, 供所有员工使用, 从而避免重复劳动, 提高工作效率。
    - **辅助决策:** RAG 可以为员工提供决策支持, 例如, 一个市场分析师可以利用 RAG Agent 来检索市场调研报告、竞争对手分析等信息, 从而更好地制定市场策略。

    ## **5.7 RAG 实现的最佳实践 (Best Practices for RAG Implementation)**


    为了充分发挥 RAG 的优势, 在实际应用中, 我们需要遵循一些最佳实践。


    ### **5.7.1 文档处理 (Document Processing):**

    - **5.7.1.1 质量胜于数量 (Quality over Quantity):** 选择高质量的数据源, 并对数据进行清洗和预处理, 以确保数据的准确性和一致性。与其追求大而全的知识库, 不如构建一个高质量、高相关性的知识库。
    - **5.7.1.2 定期更新和维护 (Regular Updates and Maintenance):** 定期更新知识库, 添加新的文档, 删除过时的文档, 修改现有的文档, 以确保信息的准确性和时效性。可以制定一个知识库更新的流程, 例如, 每天或每周更新一次知识库, 或者在有新的文档发布时, 立即将其添加到知识库中。
    - **5.7.1.3 文本提取 (Text Extraction):** 使用高效的文本提取工具, 从不同的文档格式 (例如, PDF, HTML, DOCX 等) 中提取文本内容, 并处理各种格式问题, 例如, 表格、图片、公式等。
    - **5.7.1.4 分块策略 (Chunking Strategies):** 将文档分割成大小合适的块, 以平衡检索效率和上下文完整性。
        - **固定大小分块 (Fixed-size chunking):** 将文档分割成固定长度的块, 例如, 每 100 个单词或 512 个字符一个块。这种方法的优点是简单、高效, 缺点是可能会破坏句子的完整性, 导致语义信息的丢失。
        - **内容感知分块 (Content-aware chunking):** 根据文档的结构和内容进行分块, 例如, 根据标题、段落、句子等进行分块, 或者使用 NLP 技术识别文档中的语义边界, 进行分块。这种方法的优点是可以更好地保留文档的语义信息, 缺点是实现起来比较复杂。
        - **递归分块 (Recursive chunking):** 对文档进行递归分割, 例如, 先将文档分割成章节, 再将章节分割成段落, 最后将段落分割成句子。这种方法的优点是可以处理较长的文档, 并保留文档的层次结构, 缺点是实现起来比较复杂。
        - **专门的块 (Specialized chunks):** 针对特定类型的文档, 例如代码、表格等, 使用专门的分块策略。例如, 对于代码文件, 可以使用代码语法树 (AST) 进行分块; 对于表格数据, 可以使用表格的行或列作为块。
    - **5.7.1.5 元数据管理 (Metadata Management):** 为每个文档块添加元数据, 例如, 文档的标题、作者、来源、创建时间、标签等, 以便进行更精细的检索和过滤。
        - **元数据标准 (Metadata Standards):** 使用标准化的元数据模式, 例如, Dublin Core, [Schema.org](http://schema.org/) 等, 以便于不同系统之间的数据交换和共享。
        - **自动元数据提取 (Automatic Metadata Extraction):** 使用 NLP 技术或其他工具, 自动提取文档的元数据, 例如, 可以使用实体识别技术来提取文档中的人名、地名、机构名等, 或者使用主题模型来提取文档的主题。
    - **5.7.1.6 多格式支持 (Support for Multiple Formats):** 支持多种文档格式, 例如, PDF, HTML, DOCX, TXT 等, 以便能够处理不同来源的数据。
    - **5.7.1.7 清洗和预处理 (Cleaning and Preprocessing):** 对提取的文本进行清洗和预处理, 例如, 去除 HTML 标签、特殊字符、停用词等, 进行词干提取、词形还原等, 以提高检索的准确性。可以使用一些常用的 NLP 工具包, 例如 NLTK、SpaCy 等, 来进行文本的清洗和预处理。

    ### **5.7.2 上下文检索 (Context Retrieval):**

    - **5.7.2.1 向量数据库优化 (Vector Database Optimization):**
        - **索引策略 (Indexing Strategies):** 根据数据规模和查询需求, 选择合适的索引策略, 例如, HNSW (Hierarchical Navigable Small World), IVF (Inverted File Index) 等, 并调整索引参数, 以优化检索性能。例如, 对于需要高精度的场景, 可以选择 HNSW 索引; 对于需要高召回率的场景, 可以选择 IVF 索引。
        - **维度选择 (Dimensionality Selection):** 选择合适的向量维度, 以平衡检索的准确性和效率。通常来说, 更高的维度可以表示更丰富的语义信息, 但也需要更多的存储空间和计算时间。
        - **距离度量 (Distance Metrics):** 选择合适的距离度量方法, 例如, 余弦相似度 (Cosine Similarity)、欧几里得距离 (Euclidean Distance)、内积 (Inner Product) 等, 并根据具体的应用场景进行调整。
    - **5.7.2.2 查询扩展 (Query Expansion):**
        - 使用查询扩展技术, 例如同义词扩展、上位词/下位词扩展、基于知识图谱的查询扩展等, 以提高检索的召回率。例如, 可以将用户的查询 “人工智能的应用” 扩展为 “人工智能的应用 OR AI 的应用 OR 人工智能的用途”, 从而召回更多相关的文档。
    - **5.7.2.3 过滤和排序 (Filtering and Ranking):**
        - 使用元数据对检索结果进行过滤, 例如, 只检索特定时间范围内的文档, 或者只检索特定作者的文档。
        - 根据相关性、时间、权威性等因素对检索结果进行排序, 将最相关的文档排在前面。例如, 可以根据文档的发布时间对检索结果进行排序, 将最新的文档排在前面。
    - **5.7.2.4 缓存 (Caching):**
        - 使用缓存机制, 将常用的查询结果缓存起来, 以提高检索的速度。例如, 可以将一些常见 FAQ 问题的答案缓存起来, 当用户再次提问时, 可以直接从缓存中返回答案, 而不需要再次进行检索。
        - 可以根据实际情况, 选择合适的缓存策略, 例如 LRU (Least Recently Used)、LFU (Least Frequently Used) 等, 并设置合适的缓存大小和过期时间。

    ### **5.7.3 集成策略 (Integration Strategy):**

    - **5.7.3.1 无缝集成:** (引用第七篇文章: "Integration with existing agent capabilities should be seamless and efficient. The context system should work harmoniously with the agent’s persona, instruction, task execution, and reasoning capabilities.")
        - 将 RAG 系统与 Agent 的其他组件 (例如, 角色、指令、任务、推理引擎、工具等) 进行无缝集成, 使 RAG 成为 Agent 的一个有机组成部分, 而不是一个独立的模块。
        - 设计清晰的接口, 使 Agent 能够方便地调用 RAG 系统进行检索, 并将检索结果整合到 Agent 的工作流程中。例如, Agent 可以在需要获取外部知识时, 调用 `ContextManager` 的 `query` 方法进行检索, 并将检索到的上下文信息添加到 Prompt 中, 从而增强 LLM 的生成能力。
    - **5.7.3.2 上下文更新:** (引用第七篇文章: "The system should provide clear interfaces for context updates and maintenance.")
        - 提供清晰的接口, 以便 Agent 或外部系统可以更新知识库, 例如, 添加新的文档、删除过时的文档、修改现有的文档等。
        - 可以使用 Webhook 或消息队列等机制, 实现知识库的动态更新, 使 Agent 能够及时获取最新的信息。例如, 当一个新的产品文档发布时, 可以通过 Webhook 触发 Agent 更新知识库, 从而使 Agent 能够回答关于新产品的问题。
    - **5.7.3.3 上下文选择:**
        - 根据当前的 Agent 状态、任务需求和已经生成的对话内容, 动态地选择相关的上下文, 避免不相关或冗余的信息干扰 LLM 的生成。例如, 可以根据当前的对话主题, 选择与主题相关的上下文; 或者根据 Agent 正在执行的任务, 选择与任务相关的上下文。
        - 控制上下文的长度, 避免 Prompt 超过 LLM 的最大输入长度限制。例如, 可以设置一个最大上下文长度, 当检索到的上下文超过这个长度时, 可以根据相关性进行截断, 或者使用文本摘要等技术, 对上下文进行压缩。
    - **5.7.3.4 错误处理:**
        - 处理 RAG 系统可能出现的错误, 例如, 检索失败、LLM 生成错误等, 并提供备选方案。例如, 当检索失败时, 可以使用 LLM 自身的知识进行回答, 或者提示用户更换关键词重试; 当 LLM 生成错误时, 可以使用一些后处理技术进行修正, 或者重新生成。
    - **5.7.3.5 性能监控:**
        - 监控 RAG 系统的性能, 例如, 检索的延迟、LLM 生成的延迟、系统的吞吐量等, 并根据监控结果进行优化。例如, 可以使用一些性能分析工具来分析 RAG 系统的性能瓶颈, 并进行针对性的优化, 例如, 优化检索算法、调整 LLM 的参数、增加硬件资源等。

    ## **5.8 局限性和后续步骤 (Limitations and Future Steps)**


    尽管 RAG 技术为 AI Agent 带来了强大的情境感知能力, 但仍然存在一些局限性, 需要在未来的研究和开发中不断改进。


    ### **5.8.1 幻觉问题 (Hallucinations):**

    - LLM 仍然有可能产生幻觉, 即使使用了 RAG 技术, LLM 仍然有可能生成不符合事实或与检索到的上下文无关的内容。这可能是由于 LLM 对上下文的理解不够深入, 或者由于检索到的上下文中存在错误或误导性信息。
    - **可能的解决方案:**
        - **改进检索算法:** 提高检索结果的相关性和准确性, 减少无关或错误信息的干扰。
        - **增强 LLM 的事实核查能力:** 训练 LLM 识别和纠正自身的幻觉, 例如, 可以使用对抗性训练、强化学习等技术。
        - **引入外部知识:** 利用知识图谱等外部知识源, 对 LLM 生成的内容进行事实核查。
        - **设计更有效的 Prompt:** 通过 Prompt Engineering 引导 LLM 更加关注上下文, 减少幻觉的产生。

    ### **5.8.2 知识更新的滞后 (Lagging Knowledge Updates):**

    - RAG 系统的知识库需要定期更新, 以确保 Agent 能够获取最新的信息。然而, 知识库的更新和 LLM 对新知识的感知之间可能存在时间差, 导致 Agent 的响应出现滞后。例如, 一个新的产品发布后, 可能需要一段时间才能将其信息添加到知识库中, 并被 Agent 所利用。
    - **可能的解决方案:**
        - **更频繁的更新策略:** 缩短知识库的更新周期, 例如, 从每天更新改为每小时更新, 甚至实时更新。
        - **增量更新:** 只更新发生变化的部分, 而不是全量更新整个知识库, 以提高更新效率。
        - **使用流式处理:** 将新数据以流的形式输入到 RAG 系统, 实现实时更新。

    ### **5.8.3 难以处理复杂推理 (Difficulty Handling Complex Reasoning):**

    - RAG 主要通过提供相关的上下文信息来增强 LLM 的生成能力, 但对于需要复杂推理的任务, RAG 的作用仍然有限。例如, 对于需要进行多步逻辑推理、数学计算、代码生成等任务, RAG 提供的上下文信息可能不足以支持 LLM 完成任务。
    - **可能的解决方案:**
        - **结合其他推理增强技术:** 例如, ReAct, Chain of Thought, Reflection 等, 以提高 Agent 的推理能力。
        - **开发更强大的推理引擎:** 例如, 结合符号推理和神经网络, 构建更强大的推理引擎。
        - **将复杂任务分解成多个简单的子任务:** 通过任务分解, 降低每个子任务的推理难度, 从而使 RAG 能够更好地支持复杂任务的执行。

    ### **5.8.4 对抗性攻击 (Adversarial Attacks):**

    - RAG 系统可能容易受到对抗性攻击, 例如, 攻击者可以通过操纵知识库中的信息, 或者构造恶意的查询, 来诱导 Agent 产生错误的响应, 或者执行不安全的操作。例如, 攻击者可以在知识库中注入虚假的信息, 或者故意使用一些容易引起歧义的查询, 来误导 Agent。
    - **可能的解决方案:**
        - **知识库的安全审查:** 对知识库中的信息进行严格的安全审查, 确保信息的准确性和可靠性。
        - **查询过滤和验证:** 对用户的查询进行过滤和验证, 防止恶意查询或注入攻击。
        - **对抗性训练:** 使用对抗性样本来训练 LLM, 提高其对对抗性攻击的鲁棒性。
        - **输入验证:** 对 Agent 的输入进行验证, 例如, 检查输入的长度、格式、内容等, 防止异常输入导致 Agent 崩溃或产生错误的行为。

    ### **5.8.5 未来发展方向 (Future Directions):**

    - **5.8.5.1 更强大的文档理解 (More Sophisticated Document Understanding):**
        - 利用 NLP 技术 (例如, 实体识别、关系提取、事件抽取等) 来增强文档理解, 从非结构化文本中提取结构化信息, 构建知识图谱, 从而提高检索的准确性和效率。例如, 可以识别文档中提到的实体 (例如, 人名、地名、机构名等), 并提取实体之间的关系, 构建知识图谱, 从而支持更复杂的查询和推理。
        - 研究如何处理表格、图像、代码等多模态信息, 并将这些信息与文本信息融合起来, 以支持更丰富的查询和推理。例如, 可以识别表格中的数据, 并将其转换为结构化的数据格式, 或者提取图像中的信息, 并将其与文本信息关联起来。
    - **5.8.5.2 改进的上下文相关性排名 (Improved Context Relevance Ranking):**
        - 开发更有效的上下文相关性排名算法, 以提高检索结果的相关性和准确性。例如, 可以使用更先进的语义相似度模型, 或者利用用户的反馈信息来优化排序模型。
        - 根据不同的任务和场景, 调整相关性排序的策略, 例如, 对于一些任务, 需要更注重时效性, 而对于另一些任务, 则需要更注重权威性。
    - **5.8.5.3 高级元数据管理 (Advanced Metadata Management):**
        - 利用本体和知识图谱来增强元数据管理, 从而支持更复杂的查询和过滤。例如, 可以使用本体来定义不同类型的实体和关系, 并使用知识图谱来存储和查询实体之间的关系, 从而实现更精准的检索。
        - 自动化元数据提取, 例如, 可以使用 NLP 技术来自动提取文档的关键词、主题、作者等信息, 并将其添加到元数据中, 从而减少人工标注的工作量。
    - **5.8.5.4 与企业知识图谱集成 (Integration with Enterprise Knowledge Graphs):**
        - 将 RAG 系统与企业知识图谱集成, 以提供更全面的上下文信息, 支持更复杂的推理和决策。例如, 可以将 RAG 系统与企业的客户关系管理 (CRM) 系统、产品信息管理 (PIM) 系统等集成起来, 从而使 Agent 能够利用这些系统中的信息来回答用户的问题或执行任务。
    - **5.8.5.5 更好的分块策略 (Improved Chunking Strategies):**
        - 研究更有效的分块策略, 以更好地保留文档的语义信息, 并提高检索的效率。例如, 可以根据文档的结构和内容, 自适应地调整分块大小和策略, 或者使用更先进的 NLP 技术来进行分块。
        - 针对特定类型的文档 (例如, 代码、表格等), 开发专门的分块策略, 以提高检索的效果。例如, 对于代码文件, 可以使用代码语法树 (AST) 进行分块; 对于表格数据, 可以使用表格的行或列作为块。
    - **5.8.5.6 多模态 RAG (Multimodal RAG):**
        - 将 RAG 扩展到多模态数据, 例如, 图像、音频和视频, 以支持更丰富的查询和推理。例如, 可以根据图像的内容来检索相关的文本信息, 或者根据音频的内容来检索相关的视频片段。
    - **5.8.5.7 持续学习 (Continual Learning):**
        - 使 RAG 系统能够持续学习和更新知识库, 以适应不断变化的信息环境。例如, 可以定期抓取最新的网页, 并将其添加到知识库中, 或者使用用户反馈来更新知识库中的信息。
    - **5.8.5.8 可解释的 RAG (Explainable RAG):**
        - 提高 RAG 的可解释性, 使用户能够理解 Agent 为什么会生成当前的答案, 以及答案的来源是什么。例如, 可以在生成答案时, 同时提供相关的文档片段和链接, 方便用户进行验证和查阅。
    - **5.8.5.9 个性化的 RAG (Personalized RAG):**
        - 根据用户的个人资料和偏好, 定制 RAG 系统的检索和生成策略, 从而提供更个性化的服务。例如, 可以根据用户的历史查询记录和浏览记录, 调整检索结果的排序, 或者根据用户的兴趣爱好, 生成更符合用户口味的答案。

    ## **总结:**


    本章深入探讨了 RAG 技术及其在 AI Agent 中的应用,  详细介绍了 RAG 的核心概念、技术实现、与 Agent 架构的集成、企业级优势、最佳实践以及局限性和未来发展方向。通过 RAG,  Agent 可以有效地利用外部知识库,  增强其情境感知能力,  从而提供更准确、更相关、更个性化的响应。RAG 技术是构建企业级 AI Agent 的关键技术之一,  具有广泛的应用前景。


    通过本章的学习,  开发者可以掌握如何使用 RAG 技术来增强 AI Agent 的情境感知能力,  并将其应用于实际的开发工作中,  构建出更加智能、更加强大的 AI Agent。

