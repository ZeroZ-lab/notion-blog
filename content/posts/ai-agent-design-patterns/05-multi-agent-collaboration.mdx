---
title: AI 多智能体模式：协同智能的崛起
description: ''
date: '2025-02-21'
category: AI Agent
tags: []
published: true
cover: /images/posts/AI-多智能体模式协同智能的崛起/cover.jpg
listed: false
---


## **1. 什么是多智能体系统？**


多智能体系统是一个由多个自主智能体交互以协作或独立解决复杂问题的系统。每个智能体都可以专门处理任务、进行通信并协同工作。多智能体系统增强了模块化、可扩展性和控制性，使其适用于分布式系统、问题解决、模拟和基于 AI 的决策环境。


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-1.png)


当出现以下情况时，单个基于智能体的 Agentic AI 系统可能会面临挑战：

- 需要处理的工具太多。
- 任务变得过于专业化而难以管理。
- 上下文状态开始变得过大。

多智能体系统拥有多个 AI 智能体，它们可以：

- 共同或独立工作。
- 解决更大的复杂问题。

多智能体系统的主要优点：

- **模块化：** 独立的智能体使得开发、测试和维护代理系统变得更容易。
- **专业化：** 专业智能体可以专注于特定领域，从而提高整体系统性能。
- **控制：** 对智能体如何通信进行显式控制。

## **2. Agentic AI 多智能体模式的架构**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-2.png)


该架构展示了一个 Agentic AI 多智能体系统，其中具有专门角色的各种智能体彼此交互，并与一个总体多智能体应用程序交互，以处理用户提示并生成响应。系统中的每个智能体都有独特的功能，模拟一个协作团队，共同高效地完成任务。


**组件说明：**

- **用户交互：**
    - **提示：** 用户通过向多智能体应用程序输入提示来启动交互。
    - **响应：** 系统通过协作智能体交互处理提示，并向用户返回响应。
- **智能体及其角色：**
    - **智能体 1：软件工程师：** 专注于与软件开发相关的技术问题解决，提供编码解决方案或建议基于软件的策略。
    - **智能体 2：项目经理：** 负责项目管理方面，协调智能体之间的工作，并确保流程与总体项目目标一致。
    - **智能体 3：内容开发人员：** 生成内容、撰写草稿或协助开发项目所需的文档和创意材料。
    - **智能体 4：市场调研分析师：** 收集数据、对市场趋势进行分析，并提供洞察以指导其他智能体的策略。
- **交互流程：**
    - 智能体之间的箭头表示通信通道和协作路径。这意味着：
        - **双向箭头（双头）：** 智能体可以来回交换信息，实现迭代协作。
        - **虚线：** 表示智能体之间的辅助或间接通信路径，表明在通信流程中扮演支持角色，而不是主要的协调角色。
- **通信工作流：**
    - **启动：** 用户向多智能体系统提供提示。
    - **协调：**
        - 智能体 1（软件工程师）可以首先确定任何初始技术要求或策略。
        - 智能体 2（项目经理）与智能体 1 和其他智能体协调，确保每个人都保持一致。
        - 智能体 3（内容开发人员）创建作为输出一部分可能需要的相关内容或草稿。
        - 智能体 4（市场调研分析师）提供研究数据，这些数据对于其他智能体做出明智的决策可能至关重要。
    - **完成：** 一旦所有智能体都进行了协作，系统就会编译最终响应并将其呈现给用户。

![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-3.png)


**关键特征：**

- **协作智能：** 该架构促进了协作式问题解决，具有专业知识的智能体贡献独特的见解和技能。
- **自主性：** 每个智能体都半独立地运作，专注于其特定角色，同时保持与其他智能体的通信。
- **可扩展性：** 可以通过添加更多专业智能体来扩展模型，以解决更复杂的用户提示。

该架构在需要多样化专业知识的多方面任务中特别有效，例如研究项目、产品开发和全面的内容创建。强调不同的角色和协调的沟通可确保复杂任务的每个部分都得到高效和紧密的处理。希望你已经了解了多智能体的工作原理。现在，我们将讨论一个构建多智能体解决方案的框架。


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-4.png)

- **网络：** 每个智能体都可以与其他任何智能体通信。任何智能体都可以决定接下来调用哪个智能体。
- **主管：** 每个智能体都与一个主管智能体通信。主管智能体决定接下来应该调用哪个智能体。
- **主管（工具调用）：** 主管架构的特例。单个智能体可以表示为工具。主管智能体使用工具调用 LLM 来决定调用哪个智能体工具以及传递的参数。
- **分层：** 具有主管的主管的多智能体系统。这是主管架构的泛化，允许更复杂的控制流程。
- **自定义多智能体工作流：** 每个智能体仅与智能体的子集通信。部分流程是确定性的，只有一些智能体可以决定接下来调用哪个智能体。

**3. AutoGen：通过多智能体对话实现下一代 LLM 应用**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-5.png)


你知道许多框架（如 CrewAI、LangGraph 和 AutoGen）都为开发人员提供了构建多智能体解决方案的方法吗？今天，我们将讨论 AutoGen：


AutoGen 通过启用可定制和可对话的智能体（这些智能体设计用于在多智能体对话框架内运行）引入了 LLM 应用程序的新范式。这种设计植根于对现代 LLM 可以无缝地适应和整合反馈的理解，特别是那些针对对话进行了优化的 LLM（例如 GPT-4）。AutoGen 通过允许智能体进行对话交互来利用此功能——自主地或在人工监督下交换观察、评论和验证。


AutoGen 智能体的多功能性源于它们能够结合各种角色和行为，这些角色和行为可以根据开发人员的需求进行定制。例如，这些智能体可以被编程为编写或执行代码、整合人类反馈或验证结果。这种灵活性由开发人员可以轻松配置的模块化结构支持。每个智能体的后端都是可扩展的，允许进一步定制并增强其功能，使其超出默认设置。智能体的可对话性使它们能够保持持续的多轮对话并适应动态交互模式，使其适用于从问答和决策到复杂问题解决任务的各种应用。


**对话编程**


AutoGen 中的一项关键创新是对话编程的概念，它通过将开发过程简化为多智能体对话来革新 LLM 应用程序开发。这种编程范式将重点从传统的以代码为中心的工作流转移到以对话为中心的计算，使开发人员能够更直观地管理复杂的交互。对话编程分为两个核心步骤：

1. **定义可对话的智能体：** 开发人员通过配置内置功能来创建具有特定能力和角色的智能体。这些智能体可以设置为自主操作、与其他智能体协作，或在不同点涉及人类参与，从而确保自动化和用户控制之间的平衡。
2. **编程交互行为：** 开发人员通过以对话为中心的逻辑来编程这些智能体的交互方式。这涉及使用自然语言和代码的混合，从而实现对话模式的灵活脚本编写。AutoGen 借助可扩展或修改以用于实验或定制应用程序的即用型组件，促进了这些交互的无缝实现。

对话编程的集成支持不同 LLM 功能的模块化组合，从而能够将复杂任务划分为智能体可以协作解决的可管理子任务。该框架支撑了跨多个领域（包括研究、编码和互动娱乐）的强大且可扩展的 LLM 应用程序的开发。


**3.1 如何使用 AutoGen 编写多智能体对话？**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-6.png)


主要有三个部分：AutoGen 智能体、开发人员代码和程序执行，说明了如何使用 AutoGen 编写多智能体对话。下面是详细的分解：

1. **AutoGen 智能体**
    - **ConversableAgent：** 这是各种类型智能体运行的总体框架。该图突出显示了几种智能体类型：
        - **AssistantAgent：** 可配置选项，例如将 `human_input_mode` 设置为 "NEVER"，将 `code_execution_config` 设置为 `False`。这意味着智能体是完全自主的，并且在其操作期间不依赖于人工输入。
        - **UserProxyAgent：** 将 `human_input_mode` 设置为 "ALWAYS"，表明它是用户控制的，并且始终需要人工输入才能做出响应。
        - **GroupChatManager：** 管理群组对话中多个智能体之间的交互。
    - **统一对话接口：** 所有智能体共享用于发送、接收和生成回复的接口。
2. **开发人员代码**

    这部分演示了设置和自定义智能体之间交互的步骤。

    - **定义智能体：**
        - 定义了两个智能体，用户代理 A 和助手 B。它们可以相互通信，构成多智能体对话的基础。
    - **注册自定义回复函数：**
        - 为一个智能体（智能体 B）注册了一个自定义回复函数 (reply_func_A2B)。此函数概述了智能体 B 在被调用时如何生成回复。
        - 该函数包含一个简单的逻辑结构：

            ```python
            def reply_func_A2B(msg):
                output = input_from_human()
                if not output:
                    if msg includes code:
                        output = execute(msg)
                return output
            ```

        - 此函数允许智能体 B 从人类获取输入或执行代码（如果输入消息包含可执行命令）。
    - **启动对话：** 显示了一个示例启动行：
        - `initiate_chat("Plot a chart of META and TESLA stock price change YTD.”)`
        - 这行代码设置智能体 A 启动与智能体 B 的对话，要求它根据给定的命令绘制图表。
3. **程序执行**

    这部分详细介绍了初始化后对话如何进行。

    - **对话驱动的控制流：**
        - 交互从智能体 A 向智能体 B 发送请求开始。
        - 然后，智能体 B 接收请求并调用 `generate_reply` 函数，如果需要，该函数可能会触发代码执行。
    - **以对话为中心的计算：**
        - 流程显示了消息如何在 `generate_reply` 和智能体之间传递：
            - 例如，在尝试执行命令后，如果缺少所需的包，则会发回一条错误消息（例如，“Error: package yfinance is not installed”）。
            - 然后，回复会通知用户安装缺少的包（“Sorry! Please first pip install yfinance and then execute”）。

简而言之，它可视化了如何使用 AutoGen 编写智能体之间的对话驱动交互。该过程包括定义智能体、通过回复函数自定义其行为以及处理对话控制流，包括执行代码和响应用户请求。


AutoGen 智能体、开发人员代码和程序执行旨在指导开发人员设置自动化的多智能体交互，从定义和自定义智能体到观察对话和执行的控制流。


## **4. Agentic AI 多智能体模式实战**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-7.png)


在这里，我们将讨论 Agentic AI 多智能体对话（这受到了 [Deeplearning.ai](http://deeplearning.ai/) 的启发）。我使用的是 AutoGen，它有一个内置的智能体类，称为“Conversable agent”。


让我们从设置开始。


```python
!pip install openai
# python==3.10.13
!pip install pyautogen==0.2.25
import os
os.environ['OPENAI_API_KEY']='你的API密钥'
llm_config = {"model": "gpt-4o"}
```


该配置指定了要使用的模型 (gpt-4o)。


**定义 AutoGen 智能体**


`ConversableAgent` 类创建一个聊天机器人智能体。`human_input_mode="NEVER"` 表示智能体在对话期间不会请求人工用户输入。


```python
from autogen import ConversableAgent
agent = ConversableAgent(
   name="chatbot",
   llm_config=llm_config,
   human_input_mode="NEVER",
)
reply = agent.generate_reply(
   messages=[{"content": "你是一位著名的人工智能专家。现在给我讲两个关于人工智能的笑话。", "role": "user"}]
)
print(reply)

#输出 (示例)
# 好的，这里有两个关于人工智能的笑话：
# 1. 为什么人工智能害怕蜘蛛？因为它有太多 bug！
# 2. 为什么人工智能不擅长讲笑话？因为它的算法太严肃了！

reply = agent.generate_reply(
   messages=[{"content": "重复这个笑话。", "role": "user"}]
)
print(reply)

# 输出 (示例)
# 当然！请告诉我你想让我重复哪个笑话？
```


**设置对话**


设置两个智能体 Sunil 和 Harshit 之间的对话，其中保留了他们互动的记忆。


Harshit 和 Sunil 是 AI 驱动的智能体，专为参与社交媒体报告的幽默对话而设计。Harshit 是一位社交媒体专家和办公室喜剧演员，他使用轻松幽默的语言来保持对话的活跃性。Sunil 作为内容部门负责人和 Harshit 的上级，也具有这种喜剧特质，通过从上一个笑话的妙语开始下一个笑话来增加结构化幽默。这两个智能体都使用预配置的 LLM 设置并自主操作 (`human_input_mode=”NEVER”`)。这种动态模拟了工作场所的玩笑，将专业讨论与娱乐相结合，非常适合培训、团队模拟或内容生成。持续的喜剧流程模仿了真实的办公室互动，增强了参与度和相关性。


`ConversableAgent` 通常是一个人工智能智能体，能够根据预定义的系统消息和配置参与对话。这些智能体使用大型语言模型 (LLM) 提供的自然语言处理 (NLP) 功能来根据其系统消息指令进行智能响应。


```python
Harshit = ConversableAgent(
   name="Harshit",
   system_message=
   "你的名字是 Harshit，你是一位社交媒体专家，并在办公室做单口喜剧。"
   "这也是一场办公室喜剧"
   "这次对话是关于社交媒体报告的"
   "保持语言轻松幽默",
   llm_config=llm_config,
   human_input_mode="NEVER",
)
Sunil = ConversableAgent(
   name="Sunil",
   system_message=
   "你的名字是 Sunil，你是 Analytics Vidhya 内容部门的负责人，Harshit 是你的下属，你也在办公室做单口喜剧。"
   "从上一个笑话的妙语开始下一个笑话。"
   "这也是一场办公室喜剧，Harshit 是 Sunil 的下属"
   "这必须有趣且不那么冗长"
    "这次对话是关于社交媒体报告的",
   llm_config=llm_config,
   human_input_mode="NEVER",
)
```


两个智能体 Harshit 和 Sunil 由其独特的属性、个性和背景定义。根据他们的角色，他们被指示进行幽默的互动。


```python
chat_result = Sunil.initiate_chat(
   recipient=Harshit,
   message="我是 Sunil。Harshit，让我们继续讲笑话。",
   max_turns=3,
)
```


Sunil 使用初始消息和 3 个对话回合的限制开始与 Harshit 对话。


```python
import pprint
pprint.pprint(chat_result.chat_history)
#输出示例 (对话内容可能有所不同, 但结构类似)
```


**关于对话终止**


此代码是定义聊天机器人智能体 Harshit 和 Sunil（他们扮演单口喜剧演员）的设置的一部分。目标是自定义他们的行为，特别是他们如何处理对话终止。通过指定终止消息，机器人可以自然地结束他们的交互，遵循预定义的提示，如“我得走了”。


这有助于：

- **增强用户体验：** 用户获得更直观和类似人类的交互，并以清晰且相关的方式结束对话。
- **保持流程和幽默：** 由于这些智能体是单口喜剧演员，因此使用有趣的短语管理他们的退出台词符合他们的角色并增强了沉浸感。

```python
Harshit = ConversableAgent(
   name="Harshit",
   system_message=
   "你的名字是 Harshit，你是一位单口喜剧演员。"
   "当你准备结束对话时，说'我得走了'。",
   llm_config=llm_config,
   human_input_mode="NEVER",
   is_termination_msg=lambda msg: "我得走了" in msg["content"],
)
Sunil = ConversableAgent(
   name="Sunil",
   system_message=
   "你的名字是 Sunil，你是一位单口喜剧演员。"
   "当你准备结束对话时，说'我得走了'。",
   llm_config=llm_config,
   human_input_mode="NEVER",
   is_termination_msg=lambda msg: "我得走了" in msg["content"] or "再见" in msg["content"],
)
chat_result = joe.initiate_chat( # 应该是 Sunil.initiate_chat
   recipient=cathy, # 应该是 Harshit
   message="我是 Sunil。Harshit，让我们继续讲笑话。"
)
# 输出示例 (对话内容可能有所不同, 但结构类似, 并且会以 "我得走了" 结束)
```


**输出分析**


Sunil 和 Harshit 之间的对话展现了一种轻松幽默的交流，保持了他们定义的角色（例如，社交媒体专业知识和办公室喜剧）。


聊天记录记录了智能体之间的来回消息，展示了他们如何根据彼此的内容进行构建、响应提示并保持连贯的流程。


**关键点**

- **智能体定制：** 每个智能体都有一个定义的名称、角色和系统消息，从而实现定制的交互。
- **笑话链接：** Sunil 的系统消息确保每个笑话都建立在前一个妙语的基础上。
- **终止处理：** 两个智能体都可以识别表示对话结束的短语。
- **幽默和轻松的语言：** 该系统旨在创建一种引人入胜且诙谐的交流，强调幽默和相关性。

此设置可用于创建自动化的、基于角色的对话模拟，适用于各种应用，例如互动讲故事、聊天机器人或培训模拟。


让我们看看如何从头开始构建一个多智能体系统。


**4.1 从零开始构建 Agentic AI 多智能体模式**


首先，感谢 Michaelis Trofficus 通过展示如何从头开始构建所有 Agentic 设计模式来简化生活。在上面的部分中，我使用了 AutoGen 框架，但现在，让我们看看如何从头开始构建它。


注意：Michaelis 借鉴了 Airflow 的设计方法，使用“>>”和“<<”符号来指示智能体之间的依赖关系。在这个简化的微型 CrewAI 模型中，智能体就像 Airflow 任务一样工作，而 Crew 就像 Airflow DAG 一样工作。


此外，他一直在研究 CrewAI 的极简版本，并从两个关键概念中汲取灵感：Crew 和 Agent。


通过研究极简版本，Michaelis 的目标可能是创建一个更简单、更精简的 CrewAI 框架，专注于基本功能并避免复杂的、无关紧要的元素。这将使系统更易于使用和调整，同时保留受 Crew（团队协调）和 Agent（个体自主性）模型启发的关键协作和任务委派功能。在深入实践之前，让我们了解一下这些：


**什么是 Crew？**


GitHub Crew: [https://github.com/joaomdmoura/crewAI](https://github.com/joaomdmoura/crewAI)


`Crew` 类旨在表示一组在协调环境中协同工作的智能体。它提供了一个以结构化方式管理和执行智能体的框架，确保尊重它们之间的依赖关系。

1. **Crew 的核心概念**
    - `Crew` 类充当智能体集合的管理者，提供了在上下文中将它们作为一个内聚单元进行处理的方法。
    - 该结构确保智能体按照尊重其依赖关系的顺序运行，从而防止冲突并实现顺利执行。
2. **Crew 类中的关键属性和方法**
    - `current_crew`（类属性）：跟踪当前活动的 `Crew` 实例。这对于在创建或注册智能体时将它们与正确的 `Crew` 上下文相关联至关重要。
    - `__init__` 方法：初始化 `Crew` 实例并创建一个空列表 `agents` 来存储属于该 crew 的智能体。
    - 上下文管理器方法（`__enter__` 和 `__exit__`）：
        - `__enter__`：当在 `with` 语句中使用 `Crew` 实例时，此方法将其设置为活动 crew。
        - `__exit__`：退出 `with` 块时清除活动 crew 上下文。
    - `add_agent` 方法：将新智能体添加到 `agents` 列表。
    - `register_agent`（静态方法）：如果 `current_crew` 不为 `None`，则通过将智能体添加到 `agents` 列表来将其与活动 `Crew` 相关联。
    - `topological_sort` 方法：
        - 目的：根据智能体的依赖关系按拓扑顺序对它们进行排序，以防止任何循环引用。
        - 过程：
            - 使用 `in-degree` 字典跟踪每个智能体的依赖关系。
            - 将没有依赖关系的智能体添加到队列中并处理它们以构建排序列表。
            - 如果检测到循环依赖关系（当排序列表与智能体总数不匹配时），则会引发错误。
    - `plot` 方法：使用 Graphviz 将智能体及其依赖关系可视化为有向无环图 (DAG)。
    - `run` 方法：
        - 功能：按 `topological_sort` 确定的顺序运行所有智能体。
        - 执行：调用每个智能体的 `run` 方法并使用 `fancy_print` 以获得更好的输出格式。
3. **工作原理**
    - **上下文管理：** `Crew` 类使用上下文管理（`__enter__` 和 `__exit__`）来创建一个范围，其中所有智能体都与特定的 crew 相关联。这使得在定义的上下文中管理智能体的生命周期和交互变得更容易。
    - **拓扑排序：** 拓扑排序确保智能体按照解决依赖关系的顺序执行。这在智能体依赖于彼此的输出或状态的场景中至关重要。
    - **图形可视化：** `plot` 方法提供了依赖结构清晰的视觉表示，有助于理解执行流程。

`Crew` 类是一个用于管理相互依赖的智能体的综合解决方案，它通过拓扑排序、可视化和执行机制提供上下文管理和依赖关系解析——所有这些对于涉及协调的基于智能体的操作的工作流都是必不可少的。


**什么是 Agent？**


在此代码上下文中，`Agent` 是一个抽象，表示能够在多智能体系统中协作以完成任务的 AI 单元。该设计结合了用于智能体间依赖关系管理、任务执行和智能体之间上下文共享的功能。`Agent` 类的关键组件是：

- **属性：**
    - 名称、背景故事、任务描述和任务预期输出：这些定义了智能体的身份和特定任务细节。
    - `ReactAgent`：用于生成响应的内置实例，表明 `Agent` 基于反应式 AI 架构。
    - 依赖项和依赖者：列出当前智能体依赖或负责的其他智能体。
    - 上下文：一个累积从其他智能体共享的上下文或结果的字符串属性，用于影响其输出。
- **初始化（****`__init__`** **方法）：**
    - 设置智能体的核心属性并将智能体注册到会话（在此上下文中称为“Crew”）（如果存在）。
    - 将智能体与工具和特定语言模型（默认为“llama-3.1-70b-versatile”）相关联。
- **依赖关系管理：**
    - 智能体使用自定义运算符（`>>` 和 `<<`）来直观地表达和建立智能体之间的依赖关系，灵感来自 Apache Airflow 等数据管道框架。
    - `add_dependency` 和 `add_dependent` 方法以编程方式处理智能体关系的管理。
- **功能：**
    - `receive_context`：接收来自依赖智能体的输出并将其添加到上下文，这丰富了智能体的任务执行。
    - `create_prompt`：根据智能体的任务、上下文和预期输出构建一个全面的提示，以指导响应生成。
    - `run`：通过使用生成的提示执行任务，运行 `ReactAgent`，然后将结果传播给所有依赖者。
- **协作机制：**
    - 智能体形成一个能够协作工作、共享上下文和输出的多智能体系统，其中每个智能体都可以根据依赖关系触发后续智能体。
    - `Crew` 抽象充当协调系统来注册和管理这些智能体，形成一个面向任务的实体网络。

总的来说，`Agent` 本质上是一个模块化的、自给自足的 AI 单元，可以与其他智能体协调和通信，以协作解决复杂任务。它充当更广泛的 AI 驱动工作流中的一个节点，能够自主处理任务并为多智能体系统的集体输出做出贡献。


**什么是 Tool？**


`Tool` 是一个充当函数包装器的类，它捕获有关函数签名的详细信息，并提供执行该函数的方法。从本质上讲，`Tool` 对象使更统一地管理函数成为可能，包括验证输入参数和呈现有关函数的元数据。


**工作原理**

- **创建工具：** 可以使用 `@tool` 装饰器来包装任何函数。这将创建一个 `Tool` 实例，其中包含有关函数的元数据并提供运行它的方法。
- **执行工具：** `Tool` 对象上的 `run` 方法允许使用关键字参数执行包装的函数。
- **输入验证：** `validate_arguments` 函数有助于确保输入的类型正确，使 `Tool` 的执行更可靠和可预测。

**开始吧！**


作者构建了他自己的 `Agent`、`Crew` 和 `tool` 的自定义实现，正如我们之前详细讨论的那样，因为将相关功能和行为封装在专用类和模块中非常有用且模块化。现在，我们将导入这些类和函数，并使用它们从头开始构建我们的多智能体系统。


**实现**


完整代码请参考此仓库：[multiagent_pattern](https://github.com/michaelistrofficus/agentic_patterns/tree/main) (链接有效)


```python
from agentic_patterns.multiagent_pattern.agent import Agent
from agentic_patterns.tool_pattern.tool import tool
from agentic_patterns.multiagent_pattern.crew import Crew

# Agent：用于创建具有特定角色和任务的智能体实例的类。
# tool：将函数公开为智能体可以使用的工具的装饰器。
# Crew：管理多个智能体并控制它们执行任务的顺序。

# 将函数定义为智能体可以使用的工具
@tool
def write_str_to_txt(string_data: str, txt_filename: str):
    """
    将字符串写入 txt 文件。

    此函数获取一个字符串并将其写入文本文件。如果文件已存在，
    它将被新数据覆盖。

    Args:
        string_data (str): 包含要写入文件的数据的字符串。
        txt_filename (str): 应将数据写入的文本文件的名称。
    """
    # 将字符串数据写入文件
    with open(txt_filename, mode='w', encoding='utf-8') as file:
        file.write(string_data)

    print(f'数据已成功写入 {txt_filename}')

# @tool 装饰器：将 write_str_to_txt 标记为智能体可以使用的工具。
# 函数用途：获取一个字符串并将其写入指定的文本文件。如果文件存在，它将被覆盖。
# 参数：
#     string_data：要写入文件的内容。
#     txt_filename：输出文件的名称。

# 创建一组智能体来执行一系列任务
with Crew() as crew:
    # 定义第一个智能体：写诗的诗人
    agent_1 = Agent(
        name="Poet Agent",
        backstory="你是一位著名的诗人，喜欢创作高质量的诗歌。",
        task_description="写一首关于生命意义的诗",
        task_expected_output="只输出诗歌，没有任何标题或介绍性句子",
    )

    # 定义第二个智能体：西班牙语翻译
    agent_2 = Agent(
        name="Poem Translator Agent",
        backstory="你是一位专业的翻译，尤其擅长西班牙语",
        task_description="将一首诗翻译成西班牙语",
        task_expected_output="只输出翻译后的诗歌，不包含其他任何内容",
    )

    # 定义第三个智能体：将内容保存到文本文件的编写者
    agent_3 = Agent(
        name="Writer Agent",
        backstory="你是一位专业的转录员，喜欢将诗歌写入 txt 文件",
        task_description="你将在上下文中收到一首西班牙语诗歌。你需要将诗歌写入 './poem.txt' 文件。",
        task_expected_output="一个包含从上下文中收到的西班牙语诗歌的 txt 文件",
        tools=write_str_to_txt,  # 允许此智能体使用前面定义的工具
    )

    # 定义智能体的工作流程顺序
    agent_1 >> agent_2 >> agent_3

# 运行智能体组，按指定的顺序执行他们的任务
    crew.run()

# with Crew() as crew:: 启动一个用于定义和运行智能体的上下文。
# agent_1：
#     Name: “Poet Agent”
#     Backstory: 将其定位为熟练的诗人。
#     Task Description: 撰写一首关于生命意义的诗歌。
#     Expected Output: 仅输出诗歌，不包含其他文本。
# agent_2：
#     Name: “Poem Translator Agent”
#     Backstory: 将其确立为西班牙语专家。
#     Task Description: 将一首诗翻译成西班牙语。
#     Expected Output: 仅翻译后的诗歌。
# agent_3：
#     Name: “Writer Agent”
#     Backstory: 将其描述为转录专家。
#     Task Description: 将西班牙语诗歌写入名为 ./poem.txt 的文本文件。
#     Tools: 可以访问 write_str_to_txt 工具以保存诗歌。
# Workflow (agent_1 >> agent_2 >> agent_3):
#     建立智能体完成其任务的顺序：首先，由 agent_1 创建诗歌，然后由 agent_2 翻译，最后由 agent_3 保存到文件。
# crew.run(): 触发按指定顺序执行任务。

# 这是 crew 的图示
crew.plot()
```


(Plot Graph 图片,  显示了 Agent 1 -> Agent 2 -> Agent 3 的流程)


完整代码：notebooks/multiagent\_pattern.ipynb  (在提供的 GitHub 仓库中)


## **5. MetaGPT 智能体：基于标准操作流程的多智能体元编程**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-8.png)


MetaGPT 是一个使用大型语言模型 (LLM) 进行多智能体协作的框架，旨在通过标准操作流程 (SOP) 复制类似人类的工作流程。这种方法通过构建 LLM 交互来减少逻辑不一致和幻觉，从而增强问题解决能力。MetaGPT 分解复杂任务、分配专门角色，并通过定义的输出确保质量。它在代码生成基准测试中优于 AutoGPT 和 LangChain 等现有系统，展示了一种用于软件工程的强大且高效的元编程解决方案。


**结构化方法和 SOP 驱动的工作流程**


MetaGPT 通过结合模仿标准操作程序 (SOP) 的结构化方法，代表了元编程的一项突破。这个基于 GPT 模型的创新框架要求智能体生成详细且结构化的输出，例如需求文档、设计工件和技术规范。这些输出确保了沟通的清晰度并最大限度地减少了协作期间的错误，从而有效地提高了生成代码的准确性和一致性。MetaGPT 中的 SOP 驱动工作流组织智能体以协同工作，类似于软件


**角色区分和任务管理**


通过定义产品经理、架构师、工程师、项目经理和质量保证工程师等专门角色，MetaGPT 将复杂的任务编排成可管理的特定操作。这种角色区分有助于项目的有效执行，每个智能体都贡献其专业知识并保持结构化沟通。整合这些实践可以实现更无缝和有效的协作过程，限制可能阻碍进度的冗余消息或错误沟通等问题。


**通信协议和反馈系统**


MetaGPT 还具有创新的通信协议，允许智能体通过结构化接口和发布-订阅机制交换有针对性的信息并访问共享资源。一个独特的功能是可执行的反馈系统，它不仅检查而且在运行时改进和运行代码，从而显着提高生成输出的质量和可靠性。


**以人为本的实践的应用**


SOP 等以人为本的实践的应用增强了系统的稳健性，使其成为构建基于 LLM 的多智能体架构的强大工具。这种在协作框架内对元编程的开创性使用为人工智能体之间更规范和类似人类的交互铺平了道路，将 MetaGPT 定位为多智能体系统设计领域的前瞻性方法。


**5.1 MetaGPT 中的软件开发流程**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-9.png)


提供的图表说明了 MetaGPT（一种基于 GPT 的元编程框架）如何通过实施标准操作程序 (SOP) 来管理软件开发过程。以下是图表的细分：

1. **用户输入：** 该过程从用户提供项目需求开始，在本例中是创建一个 2048 滑动数字益智游戏。
2. **产品经理 (PM)：**
    - 产品经理进行彻底的分析并制定详细的产品需求文档 (PRD)。
    - PRD 包括产品目标、用户故事、竞争分析和需求分析。
    - 此分析将用户需求分解为可管理的部分，并定义项目的主要目标、用户需求和设计注意事项。
3. **架构师：**
    - 架构师接收 PRD 并将其转换为系统设计。
    - 此设计包括程序调用流程、文件列表以及构建软件组件的高级计划。
    - 架构师确定组件将如何交互以及将使用哪些工具和框架（例如，使用 Python 进行游戏开发的 Pygame）。
4. **项目经理 (PM)：**
    - 项目经理然后根据架构师的系统设计创建任务列表，并将工作分配给相应的智能体。
    - 这确保了任务被明确定义并与项目需求保持一致。
5. **工程师：**
    - 工程师根据详细计划致力于实现指定的代码和功能。
    - 显示的代码片段突出显示了核心游戏逻辑的开发，其中包括 2048 游戏所需的类和函数。
6. **质量保证工程师：**
    - 质量保证工程师审查并测试代码以进行质量保证。
    - 此步骤确保游戏满足预定义的要求并保持功能和可靠性的高标准。
7. **最终产品：**
    - 该图包含最终输出的视觉表示，显示用户如何与开发的游戏进行交互。

如图所示的工作流程强调了信息和任务从一个角色到另一个角色的顺序流动，展示了 MetaGPT 如何使用定义的 SOP 来简化开发过程。这种结构化方法通过在智能体之间实施明确的角色、职责和标准通信实践，最大限度地减少了错误沟通并最大限度地提高了生产力。


**5.2 为什么多智能体系统需要 MetaGPT？**


基于大型语言模型 (LLM) 的多智能体系统在处理复杂任务时面临重大挑战。虽然它们可以有效地执行简单的对话任务，但由于逻辑一致性的固有局限性，更复杂的场景会出现问题。这些问题通常会因级联幻觉而加剧，其中错误会随着 LLM 被简单地链接在一起而复合，从而导致有缺陷或不正确的结果。


MetaGPT 通过以下几个关键创新解决了这些挑战：

- **元编程框架：** MetaGPT 提供了一种独特的元编程方法，将结构化的类似人类的工作流程集成到多智能体交互中。这种结构化框架确保智能体遵循系统化的方法，类似于人类在解决复杂问题时使用的方法。
- **标准化操作程序 (SOP)：** 通过将 SOP 编码到提示序列中，MetaGPT 将多智能体系统的工作流程与定义明确的程序对齐。这导致智能体之间更顺畅的协作并最大限度地减少逻辑不一致，因为这些 SOP 指导智能体完成结构化过程。
- **通过验证减少错误：** MetaGPT 框架内的智能体被设计为模拟类似人类的领域专业知识，使他们能够验证中间结果并检查其输出的正确性。此验证步骤对于减少可能由典型基于 LLM 的系统故障引起的错误至关重要。
- **流水线范式：** MetaGPT 引入了一种类似于流水线的任务管理方法，其中各种智能体被分配特定的角色。这种结构化的角色分配确保复杂任务被分解为可管理的子任务，促进多个智能体之间的协调努力并提高整体任务执行。
- **在基准测试中提高性能：** 在涉及协作软件工程基准测试的测试中，MetaGPT 已显示出与传统的基于聊天的多智能体系统相比，能够产生更连贯和可靠的输出。这证明了其流水线结构和特定于角色的任务划分在实现更好的任务结果方面的有效性。

多智能体系统需要 MetaGPT 通过结构化的、类似人类的工作流程来管理复杂任务的复杂性，从而减少错误和逻辑不一致。通过采用 SOP、角色分配和中间结果验证，MetaGPT 确保智能体协作高效地工作，从而实现卓越的性能和连贯的任务完成。


## **6. Agentic AI 多智能体模式的优点**


![image.png](/images/posts/AI-多智能体模式协同智能的崛起/image-10.png)


以下是多智能体模式的优点：

- **通过协作提高性能：** 与单个智能体相比，部署多个 AI 智能体一起工作通常会产生更好的结果。智能体之间的协作努力可以带来更好的结果，研究表明多智能体设置中的性能更好就证明了这一点。
- **提高注意力和理解力：** 能够处理大量输入的语言模型 (LLM) 可能仍然难以理解复杂或冗长的信息。通过为不同的智能体分配特定角色，每个智能体都可以专注于特定任务，从而增强整体理解力和效率。
- **优化子任务以提高效率：** 将复杂的项目分解为更小、可管理的子任务允许每个智能体专门化并优化其分配的角色。这种有针对性的方法可确保任务的每个组成部分都得到更精确和高效的处理。
- **复杂任务的结构化框架：** 多智能体模式提供了一种系统化的方法来分解复杂的任务，类似于开发人员在编程中使用进程或线程的方式。这种结构简化了复杂项目的管理和执行。
- **熟悉的管理类比：** 管理 AI 智能体反映了经理在组织中监督团队的方式。这种熟悉的概念有助于开发人员直观地为智能体分配角色和职责，利用对团队动态的现有理解。
- **灵活和动态的工作流程：** 每个智能体都使用自己的工作流程和内存系统进行操作，从而实现与其他智能体的动态交互和协作。这种灵活性使智能体能够参与规划、工具使用并适应不断变化的需求，从而实现高效和复杂的工作流程。
- **降低实验风险：** 管理不善的人力团队可能会产生重大后果，但尝试使用 AI 智能体的风险要小得多。这允许在优化智能体角色和交互方面进行试错，而不会产生严重影响。
- **高效的资源利用：** 将特定任务分配给专用智能体可确保有效地使用计算资源。这种有针对性的分配可防止单个智能体过载并促进平衡的工作负载分配。
- **可扩展性和适应性：** 多智能体方法允许通过根据需要添加或调整智能体来轻松扩展任务。这种适应性对于处理不同规模和复杂性的项目至关重要。
- **增强的问题解决能力：** 智能体之间的协作交互可以带来创新的解决方案并改进问题解决。多个智能体的综合专业知识和观点可以发现单个智能体可能遗漏的方法。
- **改进的任务优先级：** 通过指定每个智能体子任务的重要性，开发人员可以确保项目的关键方面得到适当的关注。这种优先级排序提高了每个智能体输出的质量和相关性。

Agentic AI 多智能体模式提供了一个强大的框架，用于提高复杂任务的性能、效率和可扩展性。通过模拟熟悉的管理结构并利用专业智能体的优势，这种方法增强了 AI 系统的功能，同时最大限度地降低了与管理不善相关的风险。


此外，要更好地了解 Agentic AI，请探索：Agentic AI 先锋计划。(原文中有一个课程链接，这里省略)


## **7. 结论**


Agentic AI 多智能体模式是 AI 设计中的一种高级架构，体现了一种协作框架，其中专门的智能体协同工作以完成复杂的任务。在反思、工具使用和规划等基础模式的基础上，Agentic AI 多智能体模式将大型项目划分为可管理的子任务，允许具有独特角色的智能体贡献其专业知识。这种模块化方法促进了协调的问题解决、自主性和可扩展性，促进了类似于现实世界管理中团队动态的高效工作流程。


多智能体模式的优点包括增强的注意力、优化的任务执行、动态适应性和改进的问题解决能力。通过模拟人类团队管理和培养智能体自主性，这种模式为跨各个行业（从软件工程到内容创建等）更复杂、可靠和高效的 AI 应用铺平了道路。

